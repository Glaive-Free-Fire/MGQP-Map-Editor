<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>MGQP Map Editor v1.2.50</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 100%; height: 60px; box-sizing: border-box; }
    .block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; }
    label { font-weight: bold; }
    .control-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .control-btn {
        position: static;
        font-size: 14px;
        padding: 4px 12px;
        border: 1px solid #ccc;
        background: #f0f0f0;
        cursor: pointer;
        border-radius: 4px;
    }
    .file-inputs { margin-bottom: 20px; display: flex; gap: 20px; align-items: center; }
    .japanese-original {
        background-color: #f5f5f5;
        border: 1px dashed #ccc;
        padding: 8px;
        margin-bottom: 5px;
        font-family: 'MS Gothic', 'Osaka-mono', monospace;
        white-space: pre-wrap;
        user-select: text;
        font-size: 16px;
    }
  </style>
</head>
<body>
  <div class="control-panel">
    <button id="wrapModeBtn" class="control-btn">Режим переноса: Остаточный</button>
    <button id="toggleScriptsBtn" class="control-btn">Скрыть Скрипты</button>

    <!-- Новые кнопки для Undo/Redo -->
    <button id="undoBtn" class="control-btn" title="Отменить (Ctrl+Z)" style="font-size:20px;">↺</button>
    <button id="redoBtn" class="control-btn" title="Повторить (Ctrl+Y)" style="font-size:20px;">↻</button>

    <!-- Старые стрелки теперь для навигации по «красным» строкам -->
    <button id="prevRedBtn" class="control-btn" title="Предыдущая красная строка">←</button>
    <span style="align-self:center; font-weight:bold; margin:0 6px;">Исправить</span>
    <button id="nextRedBtn" class="control-btn" title="Следующая красная строка">→</button>

    <!-- новая кнопка для оборачивания выделения в ∿"..."∿ -->
    <button id="wrapSlashesBtn" class="control-btn" disabled title='Wrap selection in ∿"..."∿'>"\...\"</button>

    <button id="saveBtn" class="control-btn" style="display:none;">Скачать изменённый файл</button>
    <button id="copyBtn" class="control-btn" style="display:none;">Скопировать всё извлечённое</button>
  </div>
  
  <h1>MGQP Map Editor</h1>
  
  <div class="file-inputs">
    <div>
        <label for="fileInput">1. Загрузить файл для перевода:</label><br>
        <input type="file" id="fileInput" accept=".txt">
    </div>
    <div>
        <label for="japaneseFileInput">2. Загрузить японский файл (Опционально):</label><br>
        <input type="file" id="japaneseFileInput" accept=".txt">
    </div>
  </div>

  <div id="editor"></div>

  <script>
    // ————————————————————————————————————————————
    // Кнопка "\...\": обёртывает любой выделенный текст в ∿"…∿"
    const wrapBtn = document.getElementById('wrapSlashesBtn');
    // — track which textarea was last focused:
    let currentTextarea = null;
    document.addEventListener('focusin', e => {
      if (e.target.tagName === 'TEXTAREA') currentTextarea = e.target;
    });

    function updateWrapBtn() {
      // enable only when we have a textarea with a non-empty selection
      if (currentTextarea) {
        wrapBtn.disabled = currentTextarea.selectionStart === currentTextarea.selectionEnd;
      } else {
        wrapBtn.disabled = true;
      }
    }

    // Обёртывание выделения в ∿"…∿"
    wrapBtn.addEventListener('click', () => {
      const textarea = currentTextarea;
      if (!textarea) return;
      const start = textarea.selectionStart, end = textarea.selectionEnd;
      if (start === end) return;
      const orig = textarea.value;
      const selected = orig.slice(start, end);
      const wrapped = `∿"${selected}∿"`;
      textarea.value = orig.slice(0, start) + wrapped + orig.slice(end);
      // восстановим курсор после вставки
      const newPos = start + wrapped.length;
      textarea.setSelectionRange(newPos, newPos);
      // обновляем состояние undo, и кнопку
      textarea.dispatchEvent(new Event('input', { bubbles: true }));
      updateWrapBtn();
    });
    // ————————————————————————————————————————————

    let originalLines = [];
    let textBlocks = [];
    let undoStack = [];
    let redoStack = [];
    const MAX_HISTORY = 10;
    let wrapMode = 'remainder';
    let japaneseBlockMapping = [];
    let japBlocks = [];
    let manualJapaneseMapping = [];
    let loadedFileName = '';
    let hideScripts = true;

    // навигация по красным полям: массив найденных индексов и указатель
    let redIndices = [];
    let redPointer = -1;

    function getSelections() {
      return Array.from(document.querySelectorAll('#editor textarea')).map(t => ({
        selectionStart: t.selectionStart,
        selectionEnd: t.selectionEnd
      }));
    }
    function setSelections(selections) {
      const textareas = document.querySelectorAll('#editor textarea');
      if (!selections) return;
      selections.forEach((sel, i) => {
        if (textareas[i]) {
          textareas[i].selectionStart = sel.selectionStart;
          textareas[i].selectionEnd = sel.selectionEnd;
        }
      });
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      loadedFileName = file.name;
      const reader = new FileReader();
      reader.onload = function(evt) {
        originalLines = evt.target.result.split('\n');
        extractTexts();
      };
      reader.readAsText(file, 'utf-8');
    });

    document.getElementById('japaneseFileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(evt) {
            const japaneseLines = evt.target.result.split('\n');
            extractJapaneseTexts(japaneseLines);
        };
        reader.readAsText(file, 'utf-8');
    });

    function resetJapaneseBlockMapping() {
      let used = new Array(textBlocks.length).fill(false);
      
      for (let j = 0; j < japBlocks.length; j++) {
        const japText = japBlocks[j].text;
        let found = false;
        
        for (let i = 0; i < textBlocks.length; i++) {
          // пропускаем уже использованные, без idx и помеченные как generated
          if (used[i])       { continue; }
          if (textBlocks[i].idx === undefined) { continue; }
          if (textBlocks[i].generated) { continue; }
          // Для ShowText блоков проверяем наличие имени
          if (textBlocks[i].type === 'ShowText') {
            const ruHasName = /<∾∾C\[\d+\]/.test(textBlocks[i].text);
            if (ruHasName === /^【.*】$/.test(japText)) {
              japaneseBlockMapping[j] = i;
              used[i] = true;
              found = true;
              break;
            }
          }
          // Для других типов блоков просто сопоставляем по типу
          else if (japBlocks[j] && japBlocks[j].blockType === textBlocks[i].type) {
            japaneseBlockMapping[j] = i;
            used[i] = true;
            found = true;
            break;
          }
        }
        if (!found) {
          japaneseBlockMapping[j] = -1;
        }
      }
    }

    function moveJapaneseBlock(japIdx, direction) {
      // direction: -1 (вверх), 1 (вниз)
      let current = japaneseBlockMapping[japIdx];
      if (current === -1) return;
      let i = current + direction;
      while (i >= 0 && i < textBlocks.length) {
        // Только главные строки
        if (textBlocks[i].idx !== undefined && !japaneseBlockMapping.includes(i)) {
          japaneseBlockMapping[japIdx] = i;
          renderTextBlocks();
          return;
        }
        i += direction;
      }
    }

    function extractTexts() {
      textBlocks = [];
      // Регулярные выражения для разных типов строк
      const textCmdRegex = /^\s*ShowText\(\[(.*)\]\)/;
      const displayNameRegex = /^\s*Display Name\s*=\s*"(.*)"/;
      const showChoicesRegex = /^\s*ShowChoices\(\[\[(.*)\],\s*(\d+)\]\)/;
      const whenRegex = /^\s*When\(\[(\d+),\s*"(.*)"\]\)/;
      const scriptRegex = /^\s*Script\(\[(.*)\]\)/;
      const scriptMoreRegex = /^\s*ScriptMore\(\[(.*)\]\)/;
      const showTextAttrRegex = /^\s*ShowTextAttributes\(\[(.*)\]\)/;
      
      originalLines.forEach((line, idx) => {
        // помечаем, что строка «сгенерирована» (есть "#+")
        const isGenerated = /#\+/.test(line);
        // ShowText
        let match = line.match(textCmdRegex);
        if (match) {
          let text = match[1]
            .replace(/^"(.*)"$/, '$1')
            .replace(/\\n/g, '\n')
            .replace(/\\/g, '∾');
          textBlocks.push({ idx, text, type: 'ShowText', generated: isGenerated });
          return;
        }
        // Display Name
        match = line.match(displayNameRegex);
        if (match) {
          let text = match[1].replace(/\\/g, '∾');
          textBlocks.push({ idx, text, type: 'DisplayName', generated: isGenerated });
          return;
        }
        // ShowChoices
        match = line.match(showChoicesRegex);
        if (match) {
          let choicesText = match[1];
          let defaultChoice = match[2];
          const choices = choicesText.split('", "').map(choice => 
            choice.replace(/^"/, '').replace(/"$/, '').replace(/\\/g, '∾')
          );
          textBlocks.push({ 
            idx, 
            text: choices.join(' | '), 
            type: 'ShowChoices',
            choices: choices,
            defaultChoice: parseInt(defaultChoice),
            generated: isGenerated
          });
          return;
        }
        // When
        match = line.match(whenRegex);
        if (match) {
          let choiceIndex = match[1];
          let text = match[2].replace(/\\/g, '∾');
          textBlocks.push({ 
            idx, 
            text, 
            type: 'When',
            choiceIndex: parseInt(choiceIndex),
            generated: isGenerated
          });
          return;
        }
        // Script
        match = line.match(scriptRegex);
        if (match) {
          textBlocks.push({ idx, text: match[1], type: 'Script', generated: isGenerated });
          return;
        }
        // ScriptMore
        match = line.match(scriptMoreRegex);
        if (match) {
          textBlocks.push({ idx, text: match[1], type: 'ScriptMore', generated: isGenerated });
          return;
        }
        // ShowTextAttributes
        match = line.match(showTextAttrRegex);
        if (match) {
          textBlocks.push({ idx, text: match[1], type: 'ShowTextAttributes', generated: isGenerated });
          return;
        }
      });
      resetJapaneseBlockMapping();
      renderTextBlocks();
    }

    function extractJapaneseTexts(lines) {
        const tempBlocks = [];
      
      // Регулярные выражения для разных типов японских строк
      // Теперь разрешаем пробелы после '[' и перед ']',
      // и захватываем всё внутри кавычек (ленивый режим)
      const textCmdRegex = /^\s*ShowText\(\[\s*"([\s\S]*?)"\s*\]\)/;
      const displayNameRegex = /^\s*Display Name\s*=\s*"(.*)"/;
      const showChoicesRegex = /^\s*ShowChoices\(\[\[(.*)\],\s*(\d+)\]\)/;
      const whenRegex = /^\s*When\(\[(\d+),\s*"(.*)"\]\)/;
      const scriptJpRegex = /^\s*Script\(\[(.*)\]\)/;
      const scriptMoreJpRegex = /^\s*ScriptMore\(\[(.*)\]\)/;

        lines.forEach((line, idx) => {
        // ShowText
        let match = line.match(textCmdRegex);
        if (match) {
          tempBlocks.push({ text: match[1], type: 'ShowText', originalIdx: idx });
          return;
        }
        
        // Display Name
        match = line.match(displayNameRegex);
        if (match) {
          tempBlocks.push({ text: match[1], type: 'DisplayName', originalIdx: idx });
          return;
        }
        
        // ShowChoices
        match = line.match(showChoicesRegex);
        if (match) {
          const choicesText = match[1];
          const choices = choicesText.split('", "').map(choice => 
            choice.replace(/^"/, '').replace(/"$/, '')
          );
          tempBlocks.push({ 
            text: choices.join(' | '), 
            type: 'ShowChoices', 
            originalIdx: idx,
            choices: choices
          });
          return;
        }
        
        // When
        match = line.match(whenRegex);
            if (match) {
          tempBlocks.push({ 
            text: match[2], 
            type: 'When', 
            originalIdx: idx,
            choiceIndex: parseInt(match[1])
          });
          return;
        }
        
        // Script
        match = line.match(scriptJpRegex);
        if (match) {
          tempBlocks.push({ text: match[1], type: 'Script', originalIdx: idx });
          return;
        }
        
        // ScriptMore
        match = line.match(scriptMoreJpRegex);
        if (match) {
          tempBlocks.push({ text: match[1], type: 'ScriptMore', originalIdx: idx });
          return;
        }
      });
      
      japBlocks = [];
      const nameRegex = /^【.*】$/;
      
      // Обрабатываем ShowText блоки с именами (как раньше)
        for (let i = 0; i < tempBlocks.length; i++) {
            const currentBlock = tempBlocks[i];
        if (currentBlock.type === 'ShowText') {
            if (nameRegex.test(currentBlock.text) && (i + 1 < tempBlocks.length)) {
                const nextBlock = tempBlocks[i+1];
            if (nextBlock.type === 'ShowText') {
              japBlocks.push({ 
                type: 'name', 
                text: `${currentBlock.text}\n${nextBlock.text}`,
                blockType: 'ShowText'
              });
              i++;
              continue;
            }
          }
          japBlocks.push({ 
            type: 'no_name', 
            text: currentBlock.text,
            blockType: 'ShowText'
          });
            } else {
          // Для других типов блоков просто добавляем их
          japBlocks.push({ 
            type: 'no_name', 
            text: currentBlock.text,
            blockType: currentBlock.type,
            originalIdx: currentBlock.originalIdx,
            choices: currentBlock.choices,
            choiceIndex: currentBlock.choiceIndex
          });
        }
      }
      
      linkAndRender();
    }

    function linkAndRender() {
      textBlocks.forEach(block => { delete block.japaneseLink; });
      japaneseBlockMapping = new Array(japBlocks.length).fill(-1);
      manualJapaneseMapping = []; // Сброс ручных привязок при перезагрузке

      // --- собираем только «основные» (оригинальные) русские блоки, у которых idx !== undefined
      const rusMainIndices = textBlocks.reduce((arr, b, i) => {
        if (b.idx !== undefined && !b.generated) arr.push(i);
        return arr;
      }, []);
      const rusMainBlocks = rusMainIndices.map(i => textBlocks[i]);

      if (textBlocks.length === 0 || japBlocks.length === 0) {
        renderTextBlocks();
        return;
      }
      let rusLinked = new Array(textBlocks.length).fill(false);

      // 1. ПРИОРИТЕТНАЯ ПРИВЯЗКА ДЛЯ НЕ-ShowText БЛОКОВ, пропуская все сгенерированные
      const blockTypesToMatch = ['DisplayName', 'ShowChoices', 'When', 'Script', 'ScriptMore'];
      blockTypesToMatch.forEach(type => {
        const japIndices = japBlocks.map((b, i) => b.blockType === type ? i : -1).filter(i => i !== -1);
        const rusMainTypeIndices = rusMainBlocks
          .map((b, j) => b.type === type ? j : -1)
          .filter(j => j !== -1);
        const rusIndices = rusMainTypeIndices.map(j => rusMainIndices[j]);
        const len = Math.min(japIndices.length, rusIndices.length);
        for (let k = 0; k < len; k++) {
          const japIdx = japIndices[k];
          const realRusIdx = rusIndices[k];
          if (typeof realRusIdx === 'number'
              && textBlocks[realRusIdx]
              && !textBlocks[realRusIdx].generated
              && japaneseBlockMapping[japIdx] === -1
              && !rusLinked[realRusIdx]) {
            if (type === 'When' && textBlocks[realRusIdx].choiceIndex !== japBlocks[japIdx].choiceIndex) continue;
            textBlocks[realRusIdx].japaneseLink = { type: 'no_name', text: japBlocks[japIdx].text };
            japaneseBlockMapping[japIdx] = realRusIdx;
            rusLinked[realRusIdx] = true;
          }
        }
      });

      // 2. СЕГМЕНТАЦИЯ И ПРИВЯЗКА ShowText БЛОКОВ
      let japNameIndices = [-1];
      japBlocks.forEach((b, i) => {
        if (b.blockType === 'ShowText' && b.type === 'name') japNameIndices.push(i);
      });
      japNameIndices.push(japBlocks.length);

      // Аналогично — только по оригинальным русским блокам:
      let rusMainNameIndices = [-1];
      rusMainBlocks.forEach((b, j) => {
        if (b.type === 'ShowText' && /<∾∾C\[\d+\]/.test(b.text)) rusMainNameIndices.push(j);
      });
      rusMainNameIndices.push(rusMainBlocks.length);

      // 2.1. Привязка блоков с именами (опять же — skip generated)
      for (let i = 1; i < japNameIndices.length - 1; i++) {
        const japIdx = japNameIndices[i];
        const rusMainIdx = rusMainNameIndices[i];
        if (Number.isInteger(rusMainIdx) && rusMainIdx >= 0 && rusMainIdx < rusMainIndices.length) {
          const realRusIdx = rusMainIndices[rusMainIdx];
          if (realRusIdx !== undefined
              && textBlocks[realRusIdx]
              && !textBlocks[realRusIdx].generated
              && !rusLinked[realRusIdx]) {
            textBlocks[realRusIdx].japaneseLink = { type: 'name', text: japBlocks[japIdx].text };
            japaneseBlockMapping[japIdx] = realRusIdx;
            rusLinked[realRusIdx] = true;
          }
        }
      }

      // 2.2. Привязка блоков без имен внутри сегментов
      for (let seg = 0; seg < japNameIndices.length - 1; seg++) {
        let japStart = japNameIndices[seg] + 1;
        let japEnd = japNameIndices[seg + 1];
        let rusMainStart = (rusMainNameIndices[seg] !== undefined ? rusMainNameIndices[seg] : -1) + 1;
        let rusMainEnd = rusMainNameIndices[seg + 1] !== undefined ? rusMainNameIndices[seg + 1] : rusMainBlocks.length;

        let japNoNameIndices = [];
        for (let j = japStart; j < japEnd; j++) {
          if (japBlocks[j].blockType === 'ShowText' && japBlocks[j].type === 'no_name' && japaneseBlockMapping[j] === -1) {
            japNoNameIndices.push(j);
          }
        }

        let rusMainNoNameIndices = [];
        for (let r = rusMainStart; r < rusMainEnd; r++) {
          if (rusMainBlocks[r].type === 'ShowText' && !/<∾∾C\[\d+\]/.test(rusMainBlocks[r].text) && !rusLinked[rusMainIndices[r]]) {
            rusMainNoNameIndices.push(r);
          }
        }

        const len = Math.min(japNoNameIndices.length, rusMainNoNameIndices.length);
        for (let k = 0; k < len; k++) {
          const japIdx = japNoNameIndices[k];
          const rusMainNoNameIdx = rusMainNoNameIndices[k];
          if (Number.isInteger(rusMainNoNameIdx) && rusMainNoNameIdx >= 0 && rusMainNoNameIdx < rusMainIndices.length) {
            const realRusIdx = rusMainIndices[rusMainNoNameIdx];
            if (realRusIdx !== undefined
                && textBlocks[realRusIdx]
                && !textBlocks[realRusIdx].generated) {
              textBlocks[realRusIdx].japaneseLink = { type: 'no_name', text: japBlocks[japIdx].text };
              japaneseBlockMapping[japIdx] = realRusIdx;
              rusLinked[realRusIdx] = true;
            }
          }
        }
      }
      // 3. ОБРАБОТКА ОСТАВШИХСЯ ЯПОНСКИХ БЛОКОВ (если для них не нашлось русского)
      for (let j = 0; j < japBlocks.length; j++) {
        if (japaneseBlockMapping[j] === -1) {
          let insertAt = textBlocks.length;
          for (let prev = j - 1; prev >= 0; prev--) {
            if (japaneseBlockMapping[prev] !== -1) {
              insertAt = japaneseBlockMapping[prev] + 1;
              break;
            }
          }
          const newBlock = {
            idx: undefined,
            text: 'ТРЕБУЕТСЯ ПЕРЕВОД',
            type: japBlocks[j].blockType || 'ShowText',
            generated: true
          };
          textBlocks.splice(insertAt, 0, newBlock);
          newBlock.japaneseLink = { type: japBlocks[j].type, text: japBlocks[j].text };
          japaneseBlockMapping[j] = insertAt;
          for (let k = 0; k < japaneseBlockMapping.length; k++) {
            if (k !== j && japaneseBlockMapping[k] >= insertAt) {
              japaneseBlockMapping[k]++;
            }
          }
        }
      }
      renderTextBlocks();
    }

    function pushUndo() {
      undoStack.push({
        textBlocks: JSON.parse(JSON.stringify(textBlocks)),
        selections: getSelections()
      });
      if (undoStack.length > MAX_HISTORY) undoStack.shift();
      redoStack = [];
    }

    function getGameTextInfo(txt) {
      const result = {
        rawGameText: txt,
        fullPrefix: '',        // Полный префикс для первой строки (например, @@n<...>), но теперь <∾∾C[...]
        continuationPrefix: '', // Префикс для строк-продолжений (только <...>)
        isCorrupted: false
      };
      const hasTagHint = /<∾∾C/.test(txt);
      const validNameTagRegex = /<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/;
      const hasValidTag = validNameTagRegex.test(txt);
      if (hasTagHint && !hasValidTag) {
        result.isCorrupted = true;
        return result;
      }
      // Обновленный регэксп для разделения @@n и тега имени (с учётом ∾)
      const fullMatch = txt.match(/^(@@n)?(<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>)?(.*)$/);
      if (fullMatch) {
          const newlinePrefix = fullMatch[1] || ''; // '@@n' или пустая строка
          const nameTag = fullMatch[2] || '';       // '<...>' или пустая строка
          const dialogue = fullMatch[3] || '';
          if (newlinePrefix || nameTag) {
              result.fullPrefix = newlinePrefix + nameTag;
              result.continuationPrefix = nameTag; // Самое важное: здесь нет '@@n'
              result.rawGameText = dialogue;
          }
      }
      return result;
    }

    function renderTextBlocks() {
      const editor = document.getElementById('editor');
      editor.innerHTML = '';
      document.getElementById('undoBtn').disabled = undoStack.length === 0;
      document.getElementById('redoBtn').disabled = redoStack.length === 0;
      document.getElementById('saveBtn').style.display = textBlocks.length > 0 ? '' : 'none';
      document.getElementById('copyBtn').style.display = textBlocks.length > 0 ? '' : 'none';

      if (textBlocks.length === 0) {
        editor.innerHTML = '<p>Загрузите файл для перевода.</p>';
        return;
      }
      
      textBlocks.forEach((block, i) => {
        // Скрываем скриптовые строки, если включён режим hideScripts
        if (hideScripts && (block.type === 'Script' || block.type === 'ScriptMore')) return;
        // Не отображаем ShowTextAttributes в редакторе
        if (block.type === 'ShowTextAttributes') return;
        // --- ПРОПУСКАЕМ Display Name, если он не должен отображаться ---
        if (block.type === 'DisplayName') {
          // Если японский файл не загружен — скрываем только если пустой
          if (!block.japaneseLink) {
            const ruDisplayName = block.text.trim();
            if (ruDisplayName === '') return;
          } else {
            let japDisplayName = block.japaneseLink.text ? block.japaneseLink.text.trim() : '';
            const ruDisplayName = block.text.trim();
            // Если оба пустые — не отображаем
            if (japDisplayName === '' && ruDisplayName === '') return;
            // Если японский пустой — не отображаем (даже если русский не пустой)
            if (japDisplayName === '' && ruDisplayName !== '') return;
            // Если японский не пустой — отображаем всегда (даже если русский пустой)
          }
        }
        const div = document.createElement('div');
        div.className = 'block';
        const label = document.createElement('label');
        
        // Создаем заголовок в зависимости от типа блока
        if (block.idx !== undefined) {
          switch (block.type) {
            case 'ShowText':
        label.textContent = `ShowText [строка ${block.idx+1}]:`;
              break;
            case 'DisplayName':
              label.textContent = `Display Name [строка ${block.idx+1}]:`;
              break;
            case 'ShowChoices':
              label.textContent = `ShowChoices [строка ${block.idx+1}]:`;
              break;
            case 'When':
              label.textContent = `When [строка ${block.idx+1}]:`;
              break;
            case 'Script':
              label.textContent = `Script [строка ${block.idx+1}]:`;
              break;
            case 'ScriptMore':
              label.textContent = `ScriptMore [строка ${block.idx+1}]:`;
              break;
            default:
              label.textContent = `[строка ${block.idx+1}]:`;
          }
        } else {
          label.textContent = '[продолжение]:';
        }
        div.appendChild(label);

        // Показываем японский блок для всех типов строк
        if (block.japaneseLink) {
          const japaneseText = block.japaneseLink.text;
            const pre = document.createElement('pre');
            pre.className = 'japanese-original';
          pre.textContent = japaneseText.replace(/\\n/g, '\n');
            div.appendChild(pre);
        }

        const textarea = document.createElement('textarea');
        textarea.value = block.text;
        // вешаем слушатели, чтобы активировать кнопку при выделении
        textarea.addEventListener('select',  updateWrapBtn);
        textarea.addEventListener('keyup',   updateWrapBtn);
        textarea.addEventListener('mouseup', updateWrapBtn);
        textarea.addEventListener('blur',    updateWrapBtn);
        textarea.setAttribute('data-block', i);
        div.appendChild(textarea);

        // --- Сохраняем ссылку на textarea для дубликат-логики ---
        block.dom = block.dom || {};
        block.dom.rusInput = textarea;

        const counter = document.createElement('div');
        counter.style.fontSize = '12px';
        counter.style.color = '#888';
        counter.style.margin = '2px 0 6px 0';
        div.appendChild(counter);

        const plusBtn = document.createElement('button');
        const minusBtn = document.createElement('button');
        
        div.appendChild(document.createElement('br'));
        div.appendChild(plusBtn);
        div.appendChild(minusBtn);
        
        // --- Расширенная обработка дубликатов японского текста ---
        if (block.type === 'ShowText' && block.japaneseLink && block.japaneseLink.text) {
          try {
            const currentJap = block.japaneseLink.text.trim();
            // ищем индекс оригинала, без выхода из функции
            const origIdx = textBlocks.findIndex((b, idx2) =>
              idx2 < i &&
              b.japaneseLink &&
              b.japaneseLink.text.trim() === currentJap
            );
            // если оригинал не найден, просто пропускаем логику дубликата
            if (origIdx !== -1) {
              const rusInputEl = block.dom && block.dom.rusInput;
              if (rusInputEl) {
                const dupBtn = document.createElement('button');
                dupBtn.textContent = 'Дубликат';
                dupBtn.title = `Повтор строки ${textBlocks[origIdx].idx + 1}`;
                dupBtn.style.marginLeft = '8px';
                div.appendChild(dupBtn);

                // Функция для получения объединённого текста (в одну строку)
                const collectText = start => {
                  let end = start + 1;
                  while (
                    end < textBlocks.length &&
                    textBlocks[end].type === 'ShowText' &&
                    (!textBlocks[end].japaneseLink || !textBlocks[end].japaneseLink.text.trim())
                  ) end++;
                  return textBlocks.slice(start, end)
                    .map(b => b.dom?.rusInput?.value.trim() || '')
                    .filter(v => v)
                    .join(' ');
                };

                // Функция для получения счётчика символов блока
                const getCharCount = blockIdx => {
                  const block = textBlocks[blockIdx];
                  if (!block || !block.dom?.rusInput) return 0;

                  const text = block.dom.rusInput.value;
                  if (block.type === 'ShowText' || block.type === undefined) {
                    const info = getGameTextInfo(text);

                    // 1) Убираем «полные» теги <∾∾C[...]>…∾∾C[...]>
                    // 2) Убираем оставшиеся коды ∾∾C[...]
                    // 3) Убираем остаточные C[...] (на случай, если «∾» уже срезаны)
                    // 4) Убираем одиночные символы-разделители ∾
                    const visibleText = info.rawGameText
                      .replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '')
                      .replace(/∾∾C\[\d+\]/g, '')
                      .replace(/C\[\d+\]/g, '')
                      .replace(/∾/g, '')
                      .replace(/∿/g, '')
                      .trim();

                    return visibleText.length;
                  } else {
                    // Для других типов блоков просто убираем «∾»
                    return text.replace(/∾/g, '').length;
                  }
                };

                // Получаем счётчики символов
                const origCount = getCharCount(origIdx);
                const currCount = getCharCount(i);

                // Функция обновления цвета кнопки
                const updateDupStyle = () => {
                  const origText = collectText(origIdx);
                  const currText = collectText(i);
                  const newOrigCount = getCharCount(origIdx);
                  const newCurrCount = getCharCount(i);
                  
                  // Зеленая, если текст совпадает или счётчики символов равны
                  if (currText === origText || newCurrCount === newOrigCount) {
                    dupBtn.style.backgroundColor = '#8f8';
                  } else {
                    dupBtn.style.backgroundColor = '#f88';
                  }
                };

                // Клик: вставить объединённый текст
                dupBtn.addEventListener('click', () => {
                  const origText = collectText(origIdx);
                  rusInputEl.value = origText;
                  rusInputEl.dispatchEvent(new Event('input', { bubbles: true }));
                  updateDupStyle();
                });

                // Слушатели изменений на всех связанных ShowText
                const attachListeners = start => {
                  let end = start + 1;
                  while (
                    end < textBlocks.length &&
                    textBlocks[end].type === 'ShowText' &&
                    (!textBlocks[end].japaneseLink || !textBlocks[end].japaneseLink.text.trim())
                  ) end++;
                  for (let k = start; k < end; k++) {
                    textBlocks[k].dom?.rusInput?.addEventListener('input', updateDupStyle);
                  }
                };
                attachListeners(origIdx);
                attachListeners(i);

                // Инициализация цвета
                updateDupStyle();
              }
            }
          } catch (e) {
            console.error('Ошибка обработки дубликата на строке', block.idx + 1, e);
          }
        }
        
        function updateAll() {
          const text = textarea.value;
          // Логика для ShowText и [продолжение]
          if (block.type === 'ShowText' || block.type === undefined) {
            const info = getGameTextInfo(text);
            // Новый способ очистки для подсчёта игровых символов
            const visibleText = info.rawGameText
              .replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '')
              .replace(/∾∾C\[\d+\]/g, '')
              .replace(/C\[\d+\]/g, '')
              .replace(/∾/g, '')
              .replace(/∿/g, '')
              .trim();
            const len = visibleText.length;

            if (len > 50 || info.isCorrupted) {
              textarea.style.background = '#ffd6d6';
              plusBtn.style.display = (len > 50) ? '' : 'none';
            } else {
              textarea.style.background = '';
              plusBtn.style.display = 'none';
            }
            minusBtn.style.display = (text.trim() === '' && textBlocks.length > 1) ? '' : 'none';

            let selStart = textarea.selectionStart;
            let selEnd = textarea.selectionEnd;
            let sel = Math.abs(selEnd - selStart);
            let nameLen = info.fullPrefix ? info.fullPrefix.length : 0;
            let selGame = 0;

            if (sel > 0 && selStart >= nameLen && selEnd >= nameLen) {
              const selected = info.rawGameText.substring(selStart - nameLen, selEnd - nameLen);
              selGame = selected
                .replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '')
                .replace(/∾∾C\[\d+\]/g, '')
                .replace(/C\[\d+\]/g, '')
                .replace(/∾/g, '')
                .replace(/∿/g, '')
                .length;
            } else if (sel > 0 && selEnd > nameLen && selStart < nameLen) {
              const selected = info.rawGameText.substring(0, selEnd - nameLen);
              selGame = selected
                .replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '')
                .replace(/∾∾C\[\d+\]/g, '')
                .replace(/C\[\d+\]/g, '')
                .replace(/∾/g, '')
                .replace(/∿/g, '')
                .length;
              if (selGame < 0) selGame = 0;
            }

            if (selGame > 0) {
              counter.textContent = `Игровых символов: ${len} (выделено: ${selGame})`;
            } else {
              counter.textContent = `Игровых символов: ${len}`;
            }
          } else {
            // Для других типов блоков
            const len = text.replace(/∾/g, '').length;
            textarea.style.background = '';
            plusBtn.style.display = 'none';
            minusBtn.style.display = (text.trim() === '' && textBlocks.length > 1) ? '' : 'none';
            counter.textContent = `Символов: ${len}`;
          }
        }
        
        textarea.addEventListener('input', function() {
          pushUndo();
          textBlocks[i].text = textarea.value;
          updateAll();
        });
        textarea.addEventListener('keydown', function(e) {
          if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {
            e.preventDefault(); document.getElementById('undoBtn').click();
          }
          if (e.ctrlKey && (e.key === 'y' || e.key === 'Y')) {
            e.preventDefault(); document.getElementById('redoBtn').click();
          }
        });
        textarea.addEventListener('select', updateAll);
        
        plusBtn.textContent = '+';
        plusBtn.style.marginTop = '4px';
        plusBtn.onclick = function() {
          pushUndo();
          const info = getGameTextInfo(textarea.value);
          let namePart = info.fullPrefix;
          let textPart = info.rawGameText;
          let acc = '';
          let rest = '';

          // Логика разделения текста (остается без изменений)
          if (wrapMode === 'equal') {
            const totalLen = textPart.length;
            const midPoint = Math.floor(totalLen / 2);
            let splitIndex = textPart.lastIndexOf(' ', midPoint);
            if (splitIndex === -1) { splitIndex = textPart.indexOf(' ', midPoint); }
            if (splitIndex === -1) {
                acc = textPart;
                rest = '';
            } else {
                acc = textPart.substring(0, splitIndex);
                rest = textPart.substring(splitIndex + 1);
            }
          } else { 
            const words = textPart.split(' ');
            let firstLineWords = [];
            for (const word of words) {
                firstLineWords.push(word);
                if (firstLineWords.join(' ').replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '').replace(/∾/g, '').length > 50) {
                    firstLineWords.pop();
                    break;
                }
            }
            acc = firstLineWords.join(' ');
            rest = words.slice(firstLineWords.length).join(' ');
          }

          // В первую строку — namePart + acc, во вторую — только rest (без namePart)
          textarea.value = namePart + acc.trimEnd();
          textBlocks[i].text = textarea.value;

          // --- Новый механизм разбиения окна ---
          // 1. Находим начало текущего "окна" (индекс последнего ShowTextAttributes)
          let windowStartIndex = 0;
          for (let j = i - 1; j >= 0; j--) {
            if (textBlocks[j].type === 'ShowTextAttributes') {
              windowStartIndex = j + 1;
              break;
            }
          }
          // 2. Считаем строки ShowText в текущем окне до текущего блока
          let linesInWindow = 0;
          for (let j = windowStartIndex; j <= i; j++) {
            if (textBlocks[j].type === 'ShowText' || textBlocks[j].type === undefined) {
              linesInWindow++;
            }
          }
          // 3. Если мы разделяем 4-ю строку, нужно вставить ShowTextAttributes
          if (linesInWindow >= 4 && rest.trim() !== '') {
            // Найти текст последнего атрибута для копирования
            let attrText = '["",0,0,2]';
            for (let j = i; j >= 0; j--) {
              if (textBlocks[j].type === 'ShowTextAttributes') {
                attrText = textBlocks[j].text;
                break;
              }
            }
            // Вставляем новый ShowTextAttributes, а затем новую строку ShowText
            textBlocks.splice(i + 1, 0, { type: 'ShowTextAttributes', text: attrText, idx: undefined, generated: true });
            textBlocks.splice(i + 2, 0, { text: rest.trimStart(), type: 'ShowText', idx: undefined, generated: true });
          } else {
            // В противном случае, просто добавляем новую строку как продолжение
            textBlocks.splice(i + 1, 0, { text: rest.trimStart(), type: 'ShowText', idx: undefined, generated: true });
          }
          renderTextBlocks();
        };
        
        minusBtn.textContent = '-';
        minusBtn.style.marginLeft = '8px';
        minusBtn.onclick = function() {
          pushUndo();
          // Если предыдущий блок — ShowTextAttributes и это первая ShowText после него, удаляем оба
          if (i > 0 && textBlocks[i].type === 'ShowText' && textBlocks[i - 1].type === 'ShowTextAttributes') {
            textBlocks.splice(i - 1, 2);
            renderTextBlocks();
            return;
          }
          textBlocks.splice(i, 1);
          renderTextBlocks();
        };
        
        updateAll();
        editor.appendChild(div);
      });

      // после полной отрисовки — пересчитаем красные строки и включим/выключим стрелки
      updateRedIndices();

      document.getElementById('undoBtn').onclick = function() {
        if (undoStack.length > 0) {
          redoStack.push({ textBlocks: JSON.parse(JSON.stringify(textBlocks)), selections: getSelections() });
          const state = undoStack.pop();
          textBlocks = state.textBlocks;
          renderTextBlocks();
          setTimeout(() => setSelections(state.selections), 0);
        }
      };
      document.getElementById('redoBtn').onclick = function() {
        if (redoStack.length > 0) {
          undoStack.push({ textBlocks: JSON.parse(JSON.stringify(textBlocks)), selections: getSelections() });
          const state = redoStack.pop();
          textBlocks = state.textBlocks;
          renderTextBlocks();
          setTimeout(() => setSelections(state.selections), 0);
        }
      };
    }

    document.getElementById('saveBtn').onclick = function() {
      document.querySelectorAll('textarea[data-block]').forEach(ta => {
        const i = +ta.dataset.block;
        if(textBlocks[i]) textBlocks[i].text = ta.value;
      });
      let newLines = [...originalLines];
      let lineInsertOffset = 0;
      
      // Создаем карту индексов для отслеживания изменений
      let blockIndexMap = new Map();
      
      textBlocks.forEach((block, blockIndex) => {
        if (block.idx !== undefined) {
          // Это главный блок, обновляем его
          const originalLine = originalLines[block.idx];
          const indentMatch = originalLine.match(/^\s*/);
          const indent = indentMatch ? indentMatch[0] : '';
          
          let newLine;
          switch (block.type) {
            case 'ShowText':
              // 1) ∿ → placeholder единичного слэша
              let txt = block.text.replace(/∿/g, '<<ONE>>');
              // 2) реальные переносы → literal "\n"
              txt = txt.replace(/\n/g, '\\n');
              // 3) группы ∾ → "\\"
              txt = txt.replace(/∾+/g, '\\\\');
              // 4) возвращаем плейсхолдер → "\"
              txt = txt.replace(/<<ONE>>/g, '\\');
              // 5) сводим любые повторения слэшей перед "n" (>1) к ровно "\\n"
              txt = txt.replace(/\\{2,}n/g, '\\\\n');
              // 6) убираем слэши перед ?, !, . , и перед длинным тире
              txt = txt.replace(/\\(?=[\?\.\!\,—])/g, '');
              // 7) эскейпим кавычки
              let newText = txt.replace(/(?<!\\)"/g, '\\"');
              // итоговая строка
              newLine = originalLine.replace(/\[(.*)\]/, `["${newText}"]`);
              break;
            case 'ShowTextAttributes':
              newLine = originalLine.replace(/\[(.*)\]/, `[${block.text}]`);
              break;
            case 'DisplayName':
              const displayText = block.text.replace(/∾/g, '\\').replace(/"/g, '\\"');
              newLine = originalLine.replace(/"(.*)"/, `"${displayText}"`);
              break;
            case 'ShowChoices':
              // Разбираем текст обратно на варианты выбора
              const choices = block.text.split(' | ');
              const choicesFormatted = choices.map(choice => 
                `"${choice.replace(/∾/g, '\\').replace(/"/g, '\\"')}"`
              ).join(', ');
              newLine = originalLine.replace(/\[\[(.*)\],\s*(\d+)\]/, `[[${choicesFormatted}], ${block.defaultChoice || 0}]`);
              break;
            case 'When':
              const whenText = block.text.replace(/∾/g, '\\').replace(/"/g, '\\"');
              newLine = originalLine.replace(/\[(\d+),\s*"(.*)"\]/, `[${block.choiceIndex || 0}, "${whenText}"]`);
              break;
            case 'Script':
              newLine = originalLine.replace(/\[(.*)\]/, `[${block.text}]`);
              break;
            case 'ScriptMore':
              newLine = originalLine.replace(/\[(.*)\]/, `[${block.text}]`);
              break;
            default:
              newLine = originalLine;
          }
          
          newLines[block.idx + lineInsertOffset] = indent + newLine.trimStart();
          blockIndexMap.set(blockIndex, block.idx + lineInsertOffset);
        } else {
          // Это продолжение, вставляем его как новую строку (ShowText или ShowTextAttributes)
          // Находим отступ предыдущей главной строки
          let lastMainBlockIdx = -1;
          for (let j = blockIndex - 1; j >= 0; j--) {
            if (textBlocks[j].idx !== undefined) {
              lastMainBlockIdx = textBlocks[j].idx;
              break;
            }
          }
          let indent = '';
          if (lastMainBlockIdx !== -1) {
            const originalLine = originalLines[lastMainBlockIdx];
            const indentMatch = originalLine.match(/^\s*/);
            indent = indentMatch ? indentMatch[0] : '';
          }
          if (block.type === 'ShowTextAttributes') {
            newLines.splice(lastMainBlockIdx + 1 + lineInsertOffset, 0, indent + `ShowTextAttributes([${block.text}])` + (block.generated ? ' #+' : ''));
            lineInsertOffset++;
            blockIndexMap.set(blockIndex, lastMainBlockIdx + 1 + lineInsertOffset - 1);
          } else {
            let cont = block.text.replace(/∿/g, '<<ONE>>');
            cont = cont.replace(/\n/g, '\\n');
            cont = cont.replace(/∾+/g, '\\\\');
            cont = cont.replace(/<<ONE>>/g, '\\');
            cont = cont.replace(/\\{2,}n/g, '\\\\n');
            cont = cont.replace(/\\(?=[\?\.\!\,—])/g, '');
            let newText = cont.replace(/(?<!\\)"/g, '\\"');
            newLines.splice(lastMainBlockIdx + 1 + lineInsertOffset, 0, indent + `ShowText(["${newText}"])` + (block.generated ? ' #+' : ''));
            lineInsertOffset++;
            blockIndexMap.set(blockIndex, lastMainBlockIdx + 1 + lineInsertOffset - 1);
          }
        }
      });
      
      // Удаляем все строки, которые не были обработаны (удаленные блоки)
      let linesToRemove = [];
      for (let i = 0; i < newLines.length; i++) {
        const line = newLines[i].trim();
        if (line.match(/^\s*ShowText\(\[.*\]\)/) || 
            line.match(/^\s*Display Name\s*=\s*".*"/) ||
            line.match(/^\s*ShowChoices\(\[\[.*\],\s*\d+\]\)/) ||
            line.match(/^\s*When\(\[\d+,\s*".*"\]\)/)) {
          // Проверяем, была ли эта строка обработана
          let wasProcessed = false;
          for (let [blockIndex, lineIndex] of blockIndexMap) {
            if (lineIndex === i) {
              wasProcessed = true;
              break;
            }
          }
          if (!wasProcessed) {
            linesToRemove.push(i);
          }
        }
      }
      
      // Удаляем строки в обратном порядке, чтобы индексы не сбились
      for (let i = linesToRemove.length - 1; i >= 0; i--) {
        newLines.splice(linesToRemove[i], 1);
      }
      
      // Формируем имя файла для сохранения
      let saveName = 'Map001_edited.txt';
      if (loadedFileName) {
        const dotIdx = loadedFileName.lastIndexOf('.');
        if (dotIdx !== -1) {
          saveName = loadedFileName.slice(0, dotIdx) + '_edited' + loadedFileName.slice(dotIdx);
        } else {
          saveName = loadedFileName + '_edited.txt';
        }
      }
      const blob = new Blob([newLines.join('\n')], {type: 'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = saveName;
      a.click();
    };

    document.getElementById('copyBtn').onclick = function() {
      // Регулярное выражение для русских имён
      const ruNameTagRegex = /<∾∾C\[\d+\]/;
      // Регулярное выражение для японских имён
      const japNameRegex = /^【.*】$/;
      
      let outputLines = [];

      for (let i = 0; i < textBlocks.length; i++) {
        const block = textBlocks[i];

        // Пропускаем типы, которые не нужно копировать (например, атрибуты и скрипты)
        if (block.type === 'ShowTextAttributes' || block.type === 'Script' || block.type === 'ScriptMore') {
          continue;
        }

        let label = '';
        if (block.idx !== undefined) {
            let typeLabel = block.type || 'Unknown';
            // Приводим названия типов к единому стилю для красоты
            if (block.type === 'DisplayName') typeLabel = 'Display Name';
            if (block.type === 'ShowChoices') typeLabel = 'ShowChoices';
            if (block.type === 'ScriptMore') typeLabel = 'ScriptMore';
            label = `[${typeLabel} строка ${block.idx+1}]: `;
        } else {
            label = '[продолжение]: ';
        }
        
        const isNameBlock = ruNameTagRegex.test(block.text) || japNameRegex.test(block.text);

        // Если текущий блок ShowText является блоком имени и есть следующая строка
        if (block.type === 'ShowText' && isNameBlock && (i + 1 < textBlocks.length)) {
            const nextBlock = textBlocks[i+1];
            // И если следующий блок - это диалог (а не другое имя или тип)
            const nextIsDialogue = nextBlock.type === 'ShowText' && !ruNameTagRegex.test(nextBlock.text) && !japNameRegex.test(nextBlock.text);
            
            if (nextIsDialogue) {
                // Объединяем имя и диалог в одну строку
                outputLines.push(label + `${block.text} ${nextBlock.text}`);
                i++; // Пропускаем следующую строку, так как мы её уже использовали
                continue;
            }
        }
        
        // Для всех остальных случаев просто добавляем блок как есть
        outputLines.push(label + block.text);
      }

      const copyText = outputLines.join('\n\n');
      navigator.clipboard.writeText(copyText).then(() => {
        alert('Текст скопирован в буфер обмена!');
      }, () => {
        alert('Ошибка копирования!');
      });
    };
    
    document.getElementById('wrapModeBtn').onclick = function() {
        const btn = this;
        if (wrapMode === 'remainder') {
            wrapMode = 'equal';
            btn.textContent = 'Режим переноса: Равный';
            btn.title = 'Переносится примерно половина слов';
        } else {
            wrapMode = 'remainder';
            btn.textContent = 'Режим переноса: Остаточный';
            btn.title = 'Переносятся только слова, не вмещающиеся в лимит';
        }
    };
    document.getElementById('wrapModeBtn').title = 'Переносятся только слова, не вмещающиеся в лимит';

    // Кнопка скрытия/отображения скриптов
    document.getElementById('toggleScriptsBtn').onclick = function() {
      hideScripts = !hideScripts;
      this.textContent = hideScripts ? 'Скрыть Скрипты' : 'Показать Скрипты';
      renderTextBlocks();
    };
    document.getElementById('toggleScriptsBtn').title = 'Скрыть или показать строки Script и ScriptMore';

    // Собирает актуальный список индексов красных textarea
    function updateRedIndices() {
      redIndices = textBlocks
        .map((_, i) => i)
        .filter(i => {
          const ta = textBlocks[i].dom?.rusInput;
          return ta && window.getComputedStyle(ta).backgroundColor === 'rgb(255, 214, 214)';
        });
      // Если после пересчёта указатель ушёл за пределы — сбросим
      if (redPointer >= redIndices.length) redPointer = -1;

      // --- управление отключением кнопок ---
      const prev = document.getElementById('prevRedBtn');
      const next = document.getElementById('nextRedBtn');
      const disabled = redIndices.length === 0;
      prev.disabled = disabled;
      next.disabled = disabled;
    }

    function moveToNextRed() {
      updateRedIndices();
      if (redIndices.length === 0) return;
      // переходим к следующему, с циклом
      redPointer = (redPointer + 1) % redIndices.length;
      const idx = redIndices[redPointer];
      const ta = document.querySelector(`textarea[data-block='${idx}']`);
      ta.scrollIntoView({behavior:'smooth', block:'center'});
      ta.focus();
    }

    function moveToPrevRed() {
      updateRedIndices();
      if (redIndices.length === 0) return;
      // если ещё ни разу не двигались назад — ставим в конец
      if (redPointer < 0) redPointer = 0;
      redPointer = (redPointer - 1 + redIndices.length) % redIndices.length;
      const idx = redIndices[redPointer];
      const ta = document.querySelector(`textarea[data-block='${idx}']`);
      ta.scrollIntoView({behavior:'smooth', block:'center'});
      ta.focus();
    }

    // Привязываем кнопки
    document.getElementById('nextRedBtn').onclick = moveToNextRed;
    document.getElementById('prevRedBtn').onclick = moveToPrevRed;

    // Инициализируем состояние стрелок при загрузке
    updateRedIndices();

  </script>
</body>
</html>
