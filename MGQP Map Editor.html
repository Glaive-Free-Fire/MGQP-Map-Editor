<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>MGQP Map Editor v1.4 - Финал</title>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 100%; height: 60px; box-sizing: border-box; }
    .block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; }
    label { font-weight: bold; }
    .control-btn {
        position: fixed;
        z-index: 1000;
        font-size: 14px;
        padding: 4px 12px;
        border: 1px solid #ccc;
        background: #f0f0f0;
        cursor: pointer;
        border-radius: 4px;
    }
    .file-inputs { margin-bottom: 20px; display: flex; gap: 20px; align-items: center; }
    .japanese-original {
        background-color: #f5f5f5;
        border: 1px dashed #ccc;
        padding: 8px;
        margin-bottom: 5px;
        font-family: 'MS Gothic', 'Osaka-mono', monospace;
        white-space: pre-wrap;
        user-select: text;
        font-size: 16px;
    }
  </style>
</head>
<body>
  <button id="undoBtn" class="control-btn" style="bottom:20px;right:80px;font-size:20px;">←</button>
  <button id="redoBtn" class="control-btn" style="bottom:20px;right:30px;font-size:20px;">→</button>
  <button id="wrapModeBtn" class="control-btn" style="top:20px;right:20px;">Режим переноса: Остаточный</button>
  
  <h1>MGQP Map Editor</h1>
  
  <div class="file-inputs">
    <div>
        <label for="fileInput">1. Загрузить файл для перевода:</label><br>
        <input type="file" id="fileInput" accept=".txt">
    </div>
    <div>
        <label for="japaneseFileInput">2. Загрузить японский файл (Опционально):</label><br>
        <input type="file" id="japaneseFileInput" accept=".txt">
    </div>
  </div>

  <div id="editor"></div>
  <button id="saveBtn" style="display:none;">Скачать изменённый файл</button>
  <button id="copyBtn" style="display:none;">Скопировать всё извлечённое</button>

  <script>
    let originalLines = [];
    let textBlocks = [];
    let japaneseTextBlocks = [];
    let undoStack = [];
    let redoStack = [];
    const MAX_HISTORY = 10;
    let wrapMode = 'remainder';
    let japaneseBlockMapping = [];
    let japBlocks = [];
    let manualJapaneseMapping = [];

    function getSelections() {
      return Array.from(document.querySelectorAll('#editor textarea')).map(t => ({
        selectionStart: t.selectionStart,
        selectionEnd: t.selectionEnd
      }));
    }
    function setSelections(selections) {
      const textareas = document.querySelectorAll('#editor textarea');
      if (!selections) return;
      selections.forEach((sel, i) => {
        if (textareas[i]) {
          textareas[i].selectionStart = sel.selectionStart;
          textareas[i].selectionEnd = sel.selectionEnd;
        }
      });
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        originalLines = evt.target.result.replace(/\\/g, '@').split('\n');
        extractTexts();
      };
      reader.readAsText(file, 'utf-8');
    });

    document.getElementById('japaneseFileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function(evt) {
            const japaneseLines = evt.target.result.split('\n');
            extractJapaneseTexts(japaneseLines);
        };
        reader.readAsText(file, 'utf-8');
    });

    function resetJapaneseBlockMapping() {
      // Сопоставляем японские блоки только с подходящими русскими строками (по типу: с именем/без имени)
      japaneseBlockMapping = [];
      let used = new Array(textBlocks.length).fill(false);
      for (let j = 0; j < japaneseTextBlocks.length; j++) {
        const japText = japaneseTextBlocks[j].text;
        const japHasName = /^【.*】/.test(japText);
        let found = false;
        for (let i = 0; i < textBlocks.length; i++) {
          if (used[i]) continue;
          if (textBlocks[i].idx === undefined) continue;
          const ruHasName = /<@@C\[\d+\]/.test(textBlocks[i].text);
          if (japHasName === ruHasName) {
            japaneseBlockMapping[j] = i;
            used[i] = true;
            found = true;
            break;
          }
        }
        if (!found) japaneseBlockMapping[j] = -1;
      }
    }

    function moveJapaneseBlock(japIdx, direction) {
      // direction: -1 (вверх), 1 (вниз)
      let current = japaneseBlockMapping[japIdx];
      if (current === -1) return;
      let i = current + direction;
      while (i >= 0 && i < textBlocks.length) {
        // Только главные строки
        if (textBlocks[i].idx !== undefined && !japaneseBlockMapping.includes(i)) {
          japaneseBlockMapping[japIdx] = i;
          renderTextBlocks();
          return;
        }
        i += direction;
      }
    }

    function extractTexts() {
      textBlocks = [];
      const textCmdRegex = /^\s*ShowText\(\[(.*)\]\)/;
      originalLines.forEach((line, idx) => {
        const match = line.match(textCmdRegex);
        if (match) {
          let text = match[1];
          text = text.replace(/^"(.*)"$/, '$1').replace(/\\n/g, '\n');
          textBlocks.push({ idx, text });
        }
      });
      resetJapaneseBlockMapping();
      renderTextBlocks();
    }

    function extractJapaneseTexts(lines) {
      const tempBlocks = [];
      const textCmdRegex = /^\s*ShowText\(\["(.*)"\]\)/;
      lines.forEach((line) => {
        const match = line.match(textCmdRegex);
        if (match) { tempBlocks.push(match[1]); }
      });
      japBlocks = [];
      const nameRegex = /^【.*】$/;
      for (let i = 0; i < tempBlocks.length; i++) {
        const currentText = tempBlocks[i];
        if (nameRegex.test(currentText) && (i + 1 < tempBlocks.length)) {
          const nextText = tempBlocks[i+1];
          japBlocks.push({ type: 'name', text: `${currentText}\n${nextText}` });
          i++;
        } else {
          japBlocks.push({ type: 'no_name', text: currentText });
        }
      }
      linkAndRender();
    }

    function linkAndRender() {
      // Очищаем все привязки
      textBlocks.forEach(block => { delete block.japaneseLink; });
      if (textBlocks.length === 0 || japBlocks.length === 0) {
        renderTextBlocks();
        return;
      }
      // Находим индексы японских и русских блоков с именем
      let japNameIndices = [];
      for (let i = 0; i < japBlocks.length; i++) {
        if (japBlocks[i].type === 'name') japNameIndices.push(i);
      }
      let rusNameIndices = [];
      for (let i = 0; i < textBlocks.length; i++) {
        if (/<@@C\[\d+\]/.test(textBlocks[i].text)) rusNameIndices.push(i);
      }
      // Добавляем границы для крайних сегментов
      japNameIndices = [-1, ...japNameIndices, japBlocks.length];
      rusNameIndices = [-1, ...rusNameIndices, textBlocks.length];
      // Для каждого сегмента между именами
      japaneseBlockMapping = [];
      for (let seg = 0; seg < japNameIndices.length - 1; seg++) {
        let japStart = japNameIndices[seg];
        let japEnd = japNameIndices[seg + 1];
        let rusStart = rusNameIndices[seg];
        let rusEnd = rusNameIndices[seg + 1];
        // Привязываем японские блоки без имени к первым русским без имени в этом сегменте
        let japNoName = [];
        for (let j = japStart + 1; j < japEnd; j++) {
          if (japBlocks[j].type === 'no_name') japNoName.push(j);
        }
        let rusNoName = [];
        for (let r = rusStart + 1; r < rusEnd; r++) {
          if (!/<@@C\[\d+\]/.test(textBlocks[r].text)) rusNoName.push(r);
        }
        for (let k = 0; k < japNoName.length; k++) {
          let japIdx = japNoName[k];
          // Если есть ручная привязка — используем её
          let manualIdx = manualJapaneseMapping[japIdx];
          if (manualIdx !== undefined && rusNoName.includes(manualIdx)) {
            textBlocks[manualIdx].japaneseLink = { type: 'no_name', text: japBlocks[japIdx].text };
            japaneseBlockMapping[japIdx] = manualIdx;
          } else if (rusNoName[k] !== undefined && !Object.values(manualJapaneseMapping).includes(rusNoName[k])) {
            textBlocks[rusNoName[k]].japaneseLink = { type: 'no_name', text: japBlocks[japIdx].text };
            japaneseBlockMapping[japIdx] = rusNoName[k];
          } else {
            japaneseBlockMapping[japIdx] = -1;
          }
        }
      }
      // ЯВНОЕ СОПОСТАВЛЕНИЕ СТРОК С ИМЕНАМИ
      for (let i = 1; i < japNameIndices.length - 1; i++) {
        const japIdx = japNameIndices[i];
        const rusIdx = rusNameIndices[i];
        if (
          japBlocks[japIdx] &&
          japBlocks[japIdx].type === 'name' &&
          textBlocks[rusIdx] &&
          /<@@C\[\d+\]/.test(textBlocks[rusIdx].text)
        ) {
          textBlocks[rusIdx].japaneseLink = { type: 'name', text: japBlocks[japIdx].text };
          japaneseBlockMapping[japIdx] = rusIdx;
        }
      }
      renderTextBlocks();
    }

    function pushUndo() {
      undoStack.push({
        textBlocks: JSON.parse(JSON.stringify(textBlocks)),
        selections: getSelections()
      });
      if (undoStack.length > MAX_HISTORY) undoStack.shift();
      redoStack = [];
    }

    function getGameTextInfo(txt) {
      const result = {
        rawGameText: txt,
        nameAndPrefix: '',
        isCorrupted: false
      };
      const hasTagHint = /<@@C/.test(txt);
      const validNameTagRegex = /<@@C\[\d+\](?:.*?)@@C\[\d+\]>/;
      const hasValidTag = validNameTagRegex.test(txt);

      if (hasTagHint && !hasValidTag) {
        result.isCorrupted = true;
        return result;
      }
      
      const fullMatch = txt.match(new RegExp(`^(.*?@@n)?(${validNameTagRegex.source})?(.*)$`));
      if (fullMatch) {
          const prefix = fullMatch[1] || '';
          const nameTag = fullMatch[2] || '';
          const dialogue = fullMatch[3] || '';
          if (prefix || nameTag) {
              result.nameAndPrefix = prefix + nameTag;
              result.rawGameText = dialogue;
          }
      }
      return result;
    }

    function moveJapaneseLinkDown(rusIdx) {
      // Находим японский блок, привязанный к этой строке (только для no_name)
      let japIdx = -1;
      for (let i = 0; i < japBlocks.length; i++) {
        if (japBlocks[i].type === 'no_name' && manualJapaneseMapping[i] === rusIdx) {
          japIdx = i;
          break;
        }
      }
      if (japIdx === -1) {
        // Если нет ручной привязки, ищем по текущему сопоставлению
        for (let i = 0; i < japBlocks.length; i++) {
          if (japBlocks[i].type === 'no_name' && japaneseBlockMapping[i] === rusIdx) {
            japIdx = i;
            break;
          }
        }
      }
      if (japIdx === -1) return;
      // Ищем следующую подходящую строку без имени
      let nextIdx = rusIdx + 1;
      while (nextIdx < textBlocks.length) {
        if (!/<@@C\[\d+\]/.test(textBlocks[nextIdx].text) && !Object.values(manualJapaneseMapping).includes(nextIdx)) {
          manualJapaneseMapping[japIdx] = nextIdx;
          linkAndRender();
          return;
        }
        nextIdx++;
      }
    }

    function renderTextBlocks() {
      const editor = document.getElementById('editor');
      editor.innerHTML = '';
      document.getElementById('undoBtn').disabled = undoStack.length === 0;
      document.getElementById('redoBtn').disabled = redoStack.length === 0;
      document.getElementById('saveBtn').style.display = textBlocks.length > 0 ? '' : 'none';
      document.getElementById('copyBtn').style.display = textBlocks.length > 0 ? '' : 'none';

      if (textBlocks.length === 0) {
        editor.innerHTML = '<p>Загрузите файл для перевода.</p>';
        return;
      }
      
      textBlocks.forEach((block, i) => {
        const div = document.createElement('div');
        div.className = 'block';
        const label = document.createElement('label');
        label.textContent = block.idx !== undefined ? `ShowText [строка ${block.idx+1}]:` : 'ShowText [продолжение]:';
        div.appendChild(label);
        
        // Показываем японский блок только если есть привязка
        if (block.japaneseLink) {
          const japaneseText = block.japaneseLink.text;
          const pre = document.createElement('pre');
          pre.className = 'japanese-original';
          pre.textContent = japaneseText.replace(/\\n/g, '\n');
          div.appendChild(pre);
        }
        
        const textarea = document.createElement('textarea');
        textarea.value = block.text;
        textarea.setAttribute('data-block', i);
        div.appendChild(textarea);

        const counter = document.createElement('div');
        counter.style.fontSize = '12px';
        counter.style.color = '#888';
        counter.style.margin = '2px 0 6px 0';
        div.appendChild(counter);

        const plusBtn = document.createElement('button');
        const minusBtn = document.createElement('button');
        
        div.appendChild(document.createElement('br'));
        div.appendChild(plusBtn);
        div.appendChild(minusBtn);
        
        // Кнопка "Доп Строка" для строк без имени, если над ними есть японский блок без имени
        if (!/<@@C\[\d+\]/.test(block.text) && block.japaneseLink && block.japaneseLink.type === 'no_name') {
          const extraBtn = document.createElement('button');
          extraBtn.textContent = 'Доп Строка';
          extraBtn.title = 'Сместить японский блок на следующую строку';
          extraBtn.style.marginLeft = '8px';
          // Оборачиваем в отдельный div для выравнивания вправо
          const rightDiv = document.createElement('div');
          rightDiv.style.float = 'right';
          rightDiv.appendChild(extraBtn);
          extraBtn.onclick = function() {
            moveJapaneseLinkDown(i);
          };
          div.appendChild(rightDiv);
        }
        
        function updateAll() {
          const text = textarea.value;
          const info = getGameTextInfo(text);
          const len = info.rawGameText.replace(/@/g, '').length;

          if (len > 50 || info.isCorrupted) {
            textarea.style.background = '#ffd6d6';
            plusBtn.style.display = (len > 50) ? '' : 'none';
          } else {
            textarea.style.background = '';
            plusBtn.style.display = 'none';
          }
          minusBtn.style.display = (text.trim() === '' && textBlocks.length > 1) ? '' : 'none';

          let selStart = textarea.selectionStart;
          let selEnd = textarea.selectionEnd;
          let sel = Math.abs(selEnd - selStart);
          let nameLen = info.nameAndPrefix.length;
          let selGame = 0;

          if (sel > 0 && selStart >= nameLen && selEnd >= nameLen) {
            selGame = selEnd - nameLen;
          } else if (sel > 0 && selEnd > nameLen && selStart < nameLen) {
            selGame = selEnd - nameLen;
            if (selGame < 0) selGame = 0;
          }

          if (selGame > 0) {
            counter.textContent = `Игровых символов: ${len} (выделено: ${selGame})`;
          } else {
            counter.textContent = `Игровых символов: ${len}`;
          }
        }
        
        textarea.addEventListener('input', function() {
          pushUndo();
          textBlocks[i].text = textarea.value;
          updateAll();
        });
        textarea.addEventListener('keydown', function(e) {
          if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {
            e.preventDefault(); document.getElementById('undoBtn').click();
          }
          if (e.ctrlKey && (e.key === 'y' || e.key === 'Y')) {
            e.preventDefault(); document.getElementById('redoBtn').click();
          }
        });
        textarea.addEventListener('select', updateAll);
        
        plusBtn.textContent = '+';
        plusBtn.style.marginTop = '4px';
        plusBtn.onclick = function() {
          pushUndo();
          const info = getGameTextInfo(textarea.value);
          const namePart = info.nameAndPrefix;
          const textPart = info.rawGameText;
          let acc = '';
          let rest = '';

          if (wrapMode === 'equal') {
            const totalLen = textPart.length;
            const midPoint = Math.floor(totalLen / 2);
            let splitIndex = textPart.lastIndexOf(' ', midPoint);
            if (splitIndex === -1) { 
                splitIndex = textPart.indexOf(' ', midPoint);
            }
            if (splitIndex === -1) {
                acc = textPart;
                rest = '';
            } else {
                acc = textPart.substring(0, splitIndex);
                rest = textPart.substring(splitIndex + 1);
            }
          } else { 
            const words = textPart.split(' ');
            let firstLineWords = [];
            for (const word of words) {
                firstLineWords.push(word);
                if (firstLineWords.join(' ').replace(/@/g, '').length > 50) {
                    firstLineWords.pop();
                    break;
                }
            }
            acc = firstLineWords.join(' ');
            rest = words.slice(firstLineWords.length).join(' ');
          }

          textarea.value = namePart + acc.trimEnd();
          textBlocks[i].text = textarea.value;
          textBlocks.splice(i + 1, 0, { text: rest.trimStart() });
          renderTextBlocks();
        };
        
        minusBtn.textContent = '-';
        minusBtn.style.marginLeft = '8px';
        minusBtn.onclick = function() {
          pushUndo();
          textBlocks.splice(i, 1);
          renderTextBlocks();
        };
        
        updateAll();
        editor.appendChild(div);
      });

      document.getElementById('undoBtn').onclick = function() {
        if (undoStack.length > 0) {
          redoStack.push({ textBlocks: JSON.parse(JSON.stringify(textBlocks)), selections: getSelections() });
          const state = undoStack.pop();
          textBlocks = state.textBlocks;
          renderTextBlocks();
          setTimeout(() => setSelections(state.selections), 0);
        }
      };
      document.getElementById('redoBtn').onclick = function() {
        if (redoStack.length > 0) {
          undoStack.push({ textBlocks: JSON.parse(JSON.stringify(textBlocks)), selections: getSelections() });
          const state = redoStack.pop();
          textBlocks = state.textBlocks;
          renderTextBlocks();
          setTimeout(() => setSelections(state.selections), 0);
        }
      };
    }

    document.getElementById('saveBtn').onclick = function() {
      document.querySelectorAll('textarea[data-block]').forEach(ta => {
        const i = +ta.dataset.block;
        if(textBlocks[i]) textBlocks[i].text = ta.value;
      });
      let newLines = [...originalLines];
      let lineInsertOffset = 0;
      textBlocks.forEach(block => {
        if (block.idx !== undefined) {
          // Это главный блок, обновляем его
          const newText = block.text.replace(/@/g, '\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
          // Сохраняем отступ из оригинальной строки
          const originalLine = originalLines[block.idx];
          const indentMatch = originalLine.match(/^(\s*)/);
          const indent = indentMatch ? indentMatch[1] : '';
          newLines[block.idx + lineInsertOffset] = originalLine.replace(/\[(.*)\]/, `["${newText}"]`);
          newLines[block.idx + lineInsertOffset] = indent + newLines[block.idx + lineInsertOffset].trimStart();
        } else {
          // Это продолжение, вставляем его как новую строку
          const newText = block.text.replace(/@/g, '\\').replace(/\n/g, '\\n').replace(/"/g, '\\"');
          // Находим отступ предыдущей главной строки
          let lastMainBlockIdx = -1;
          for (let j = textBlocks.indexOf(block) - 1; j >= 0; j--) {
            if (textBlocks[j].idx !== undefined) {
              lastMainBlockIdx = textBlocks[j].idx;
              break;
            }
          }
          let indent = '';
          if (lastMainBlockIdx !== -1) {
            const originalLine = originalLines[lastMainBlockIdx];
            const indentMatch = originalLine.match(/^(\s*)/);
            indent = indentMatch ? indentMatch[1] : '';
          }
          newLines.splice(lastMainBlockIdx + 1 + lineInsertOffset, 0, indent + `ShowText(["${newText}"])`);
          lineInsertOffset++;
        }
      });
      const blob = new Blob([newLines.join('\n')], {type: 'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'Map001_edited.txt';
      a.click();
    };

    document.getElementById('copyBtn').onclick = function() {
      let copyText = textBlocks.map(block => {
        if(block.idx === undefined) {
            return `[продолжение]: ${block.text}`
        }
        return `[строка ${block.idx+1}]: ${block.text}`
      }).join('\n\n');
      navigator.clipboard.writeText(copyText).then(() => {
        alert('Текст скопирован в буфер обмена!');
      }, () => {
        alert('Ошибка копирования!');
      });
    };
    
    document.getElementById('wrapModeBtn').onclick = function() {
        const btn = this;
        if (wrapMode === 'remainder') {
            wrapMode = 'equal';
            btn.textContent = 'Режим переноса: Равный';
            btn.title = 'Переносится примерно половина слов';
        } else {
            wrapMode = 'remainder';
            btn.textContent = 'Режим переноса: Остаточный';
            btn.title = 'Переносятся только слова, не вмещающиеся в лимит';
        }
    };
    document.getElementById('wrapModeBtn').title = 'Переносятся только слова, не вмещающиеся в лимит';

  </script>
</body>
</html>
