<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>MGQP Map Editor v1.4.30</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="Java scripts/restore-mode.js"></script>
  <script src="Java scripts/test_mode.js"></script>
  <script src="Java scripts/main_script.js"></script>
  <script src="Java scripts/batch_file_processing.js"></script>
  <style>
    body { font-family: sans-serif; margin: 20px; }
    textarea { width: 100%; height: 60px; box-sizing: border-box; }
    .block { margin-bottom: 20px; padding: 10px; border: 1px solid #ddd; border-radius: 6px; }
    label { font-weight: bold; }
    .control-panel {
      position: fixed;
      top: 20px;
      right: 20px;
      display: flex;
      gap: 12px;
      z-index: 1000;
    }
    .control-btn {
        position: static;
        font-size: 14px;
        padding: 4px 12px;
        border: 1px solid #ccc;
        background: #f0f0f0;
        cursor: pointer;
        border-radius: 4px;
    }
    .file-inputs { margin-bottom: 20px; display: flex; gap: 20px; align-items: center; }
    .japanese-original {
        background-color: #f5f5f5;
        border: 1px dashed #ccc;
        padding: 8px;
        margin-bottom: 5px;
        font-family: 'MS Gothic', 'Osaka-mono', monospace;
        white-space: pre-wrap;
        user-select: text;
        font-size: 16px;
    }
    /* --- Плавающая панель вкладок --- */
    .floating-tab-panel {
      position: fixed;
      right: 28px;
      bottom: 28px;
      z-index: 2000;
      display: flex;
      flex-direction: column;
      gap: 10px;
      background: rgba(255,255,255,0.95);
      box-shadow: 0 2px 12px rgba(0,0,0,0.10);
      border-radius: 10px;
      padding: 12px 10px;
      border: 1px solid #ccc;
    }
    .floating-tab-panel .control-btn {
      font-size: 14px;
      padding: 5px 10px;
      min-width: 130px;
      border-radius: 5px;
      font-weight: bold;
      box-shadow: 0 1px 4px rgba(0,0,0,0.04);
      transition: background 0.2s, color 0.2s;
    }
    .floating-tab-panel .control-btn:active {
      background: #e0e0e0;
    }
    @media (max-width: 600px) {
      .floating-tab-panel {
        right: 8px;
        bottom: 8px;
        padding: 6px 4px;
      }
      .floating-tab-panel .control-btn {
        font-size: 15px;
        min-width: 120px;
        padding: 6px 10px;
      }
    }
  </style>
</head>
<body>
  <div class="control-panel">
    <button id="wrapModeBtn" class="control-btn">Режим переноса: Остаточный</button>
    <button id="splitAllBtn" class="control-btn">Разделить Строки</button>

    <!-- Новые кнопки для Undo/Redo -->
    <button id="undoBtn" class="control-btn" title="Отменить (Ctrl+Z)" style="font-size:20px;">↺</button>
    <button id="redoBtn" class="control-btn" title="Повторить (Ctrl+Y)" style="font-size:20px;">↻</button>

    <!-- Старые стрелки теперь для навигации по «красным» строкам -->
    <button id="prevRedBtn" class="control-btn" title="Предыдущая красная строка">←</button>
    <span style="align-self:center; font-weight:bold; margin:0 6px;">Исправить</span>
    <button id="nextRedBtn" class="control-btn" title="Следующая красная строка">→</button>

    <!-- новая кнопка для оборачивания выделения в ∿"..."∿ -->
    <button id="wrapSlashesBtn" class="control-btn" disabled title='Wrap selection in ∿"..."∿'>"\...\"</button>

    <button id="saveBtn" class="control-btn" style="display:none;">Скачать изменённый файл</button>
    <button id="copyBtn" class="control-btn" style="display:none;">Скопировать всё извлечённое</button>

    <!-- Кнопка восстановления структуры -->
    <button id="restoreStructBtn" class="control-btn" style="background:#cdf; display:none;">Восстановить структуру CommonEvent</button>
    <button id="fixScriptBtn" class="control-btn" style="background:#fcd; display:none;">Исправить ошибки Script</button>
    <button id="fixIndentBtn" class="control-btn" style="background:#fde; display:none;">Исправить отступы</button>
    <button id="syncEditorBtn" class="control-btn" style="background:#ffc; display:none;">Обновить редактор</button>

    <!-- Лампочка и процент совпадения -->
    <div id="matchLampContainer" style="display:none; text-align:center;">
      <div id="matchPercent" style="font-size:13px; color:#444;">100%</div>
      <div id="matchLamp" style="width:22px; height:22px; border-radius:50%; background:#8f8; border:1.5px solid #888; margin:0 auto;"></div>
    </div>
  </div>
  
  <h1>MGQP Map Editor</h1>
  
  <div class="file-inputs">
    <div>
        <label for="fileInput">1. Загрузить файл для перевода:</label><br>
        <input type="file" id="fileInput" accept=".txt">
    </div>
    <div>
        <label for="japaneseFileInput">2. Загрузить японский файл (Опционально):</label><br>
        <input type="file" id="japaneseFileInput" accept=".txt">
    </div>
  </div>

  <!-- Вкладки редактора и предпросмотра -->
  <div class="floating-tab-panel">
    <button id="tabEditor" class="control-btn" style="font-weight:bold;">Редактор</button>
    <button id="tabPreview" class="control-btn">Предпросмотр файла</button>
    <button id="tabBatch" class="control-btn">Пакетная обработка</button>
  </div>
  <div id="tabContentEditor"></div>
  <div id="tabContentPreview" style="display:none;">
    <textarea id="previewArea" readonly style="width:100%;height:400px;font-family:monospace;font-size:15px;background:#f9f9f9;"></textarea>
    <div id="previewDiffs" style="margin-top:10px;"></div>
  </div>
  <div id="tabContentBatch" style="display:none;">
    <div style="margin-bottom:14px;">
      <input type="file" id="batchRuFolder" webkitdirectory multiple style="margin-bottom:8px;">
      <label for="batchRuFolder">Загрузить папку карт (русский)</label><br>
      <input type="file" id="batchJpFolder" webkitdirectory multiple style="margin-bottom:8px;">
      <label for="batchJpFolder">Загрузить папку карт (японский)</label><br>
      <button id="batchCheckBtn" class="control-btn">Проверить карты на ошибки</button>
    </div>
    <div style="margin-bottom:10px; display:flex; gap:24px; align-items:center;">
      <label style="font-size:15px; font-weight:normal; cursor:pointer;">
        <input type="checkbox" id="batchShowOnlyErrorLines" checked style="vertical-align:middle; margin-right:6px;">Показывать только строки с ошибками
      </label>
      <label style="font-size:15px; font-weight:normal; cursor:pointer;">
        <input type="checkbox" id="batchShowOkFiles" style="vertical-align:middle; margin-right:6px;">Показывать исправные файлы
      </label>
    </div>
    <div id="batchFileList" style="margin-top:16px;"></div>
  </div>
  <div id="editor"></div>

  <script>
    // Глобальные массивы инициализируем сразу
    window.textBlocks = window.textBlocks || [];
    window.japBlocks = window.japBlocks || [];
    // === 1. Глобальные переменные для полного файла ===
    window.fullRusLines = [];
    window.fullJapLines = [];
    // ————————————————————————————————————————————
    // Кнопка "\...\": обёртывает любой выделенный текст в ∿"…∿"
    const wrapBtn = document.getElementById('wrapSlashesBtn');
    // — track which textarea was last focused:
    let currentTextarea = null;
    document.addEventListener('focusin', e => {
      if (e.target.tagName === 'TEXTAREA') currentTextarea = e.target;
    });

    function updateWrapBtn() {
      // enable only when we have a textarea with a non-empty selection
      if (currentTextarea) {
        wrapBtn.disabled = currentTextarea.selectionStart === currentTextarea.selectionEnd;
      } else {
        wrapBtn.disabled = true;
      }
    }

    // Обёртывание выделения в ∿"…∿"
    wrapBtn.addEventListener('click', () => {
      const textarea = currentTextarea;
      if (!textarea) return;
      const start = textarea.selectionStart, end = textarea.selectionEnd;
      if (start === end) return;
      const orig = textarea.value;
      const selected = orig.slice(start, end);
      const wrapped = `∿"${selected}∿"`;
      textarea.value = orig.slice(0, start) + wrapped + orig.slice(end);
      // восстановим курсор после вставки
      const newPos = start + wrapped.length;
      textarea.setSelectionRange(newPos, newPos);
      // обновляем состояние undo, и кнопку
      textarea.dispatchEvent(new Event('input', { bubbles: true }));
      updateWrapBtn();
    });
    // ————————————————————————————————————————————

    let originalLines = [];
    let textBlocks = [];
    let undoStack = [];
    let redoStack = [];
    const MAX_HISTORY = 10;
    let wrapMode = 'remainder';
    let japaneseBlockMapping = [];
    let japBlocks = [];
    let manualJapaneseMapping = [];
    let loadedFileName = '';


    // навигация по красным полям: массив найденных индексов и указатель
    let redIndices = [];
    let redPointer = -1;

    function getSelections() {
      return Array.from(document.querySelectorAll('#editor textarea')).map(t => ({
        selectionStart: t.selectionStart,
        selectionEnd: t.selectionEnd
      }));
    }
    function setSelections(selections) {
      const textareas = document.querySelectorAll('#editor textarea');
      if (!selections) return;
      selections.forEach((sel, i) => {
        if (textareas[i]) {
          textareas[i].selectionStart = sel.selectionStart;
          textareas[i].selectionEnd = sel.selectionEnd;
        }
      });
    }

    window.updateMatchLamp = function() {
      const lampDiv = document.getElementById('matchLampContainer');
      if (!window.fullRusLines || !window.fullJapLines || window.fullRusLines.length === 0 || window.fullJapLines.length === 0) {
        lampDiv.style.display = 'none';
        document.getElementById('previewDiffs').innerHTML = '';
        return;
      }
      const jpContent = window.fullJapLines.join('\n');
      const ruContent = window.fullRusLines.join('\n');
      const result = window.checkMapStructureMatch(jpContent, ruContent);
      lampDiv.style.display = '';
      document.getElementById('matchPercent').textContent = result.percent + '%';
      // === Считаем точное количество ошибок (строк) ===
      let errorCount = 0;
      if (result.grouped) {
        result.grouped.forEach(ev => {
          ev.pages.forEach(page => {
            if (page.errors && page.errors.length > 0) errorCount += page.errors.length;
          });
        });
      } else {
        errorCount = result.errors ? result.errors.length : 0;
      }
      const lamp = document.getElementById('matchLamp');
      lamp.style.background = (errorCount === 0) ? '#8f8' : '#f66';
      lamp.title = (errorCount === 0)
        ? 'Структура CommonEvent полностью совпадает'
        : `Обнаружено ${errorCount} ошибок, ${result.percent}% совпадения структуры данных`;
      // --- Вывод подробной статистики во вкладке предпросмотра ---
      let statHtml = '';
      if (result.grouped) {
        result.grouped.forEach(ev => {
          ev.pages.forEach(page => {
            if (page.ok) {
              statHtml += `<div style='color:#228B22; font-weight:bold; margin:6px 0 2px 0;'>CommonEvent ${ev.eid} (${ev.name}), Page ${page.page}: OK</div>`;
            } else {
              statHtml += `<div style='color:#b00; font-weight:bold; margin:10px 0 2px 0;'>CommonEvent ${ev.eid} (${ev.name}), Page ${page.page}</div>`;
              page.errors.forEach(err => {
                // --- Добавляем номер BranchEnd если он есть ---
                const branchEndInfo = err.branchEndNumber !== undefined ? `<div style='color:#666; font-size:12px; margin-bottom:2px;'>BranchEnd ${err.branchEndNumber}</div>` : '';
                statHtml += `<div style='color:#b00; margin-left:12px; margin-bottom:8px;'>${branchEndInfo}<b>Строка ${err.line}:</b> ${err.msg}<br>`;
                if (err.jp || err.ru) {
                  statHtml += `<div style='font-size:13px; margin-top:2px;'><span style='color:#444;'>JP:</span> <pre style='display:inline; background:#f7f7f7; border-radius:4px; padding:2px 6px;'>${(err.jp||'').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</pre><br><span style='color:#444;'>RU:</span> <pre style='display:inline; background:#f7f7f7; border-radius:4px; padding:2px 6px;'>${(err.ru||'').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</pre></div>`;
                }
                statHtml += `</div>`;
              });
            }
          });
        });
        if (result.grouped.length === 0) {
          statHtml += '<span style="color:#393">Структура CommonEvent полностью совпадает.</span>';
        }
      }
      document.getElementById('previewDiffs').innerHTML = statHtml;
      
      // Обновляем видимость кнопок исправления после проверки структуры
      if (typeof window.updateFixButtonsVisibility === 'function') {
        window.updateFixButtonsVisibility();
      }
    }

    document.getElementById('fileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      loadedFileName = file.name;
      const reader = new FileReader();
      reader.onload = function(evt) {
        const lines = evt.target.result.split('\n');
        window.fullRusLines = lines.slice();
        window.originalLines = lines.slice();
        originalLines = lines.slice();
        extractTexts();
        updateMatchLamp();
        updateRedIndices();
        // Обновляем видимость кнопок исправления
        if (typeof window.updateFixButtonsVisibility === 'function') {
          window.updateFixButtonsVisibility();
        }
      };
      reader.readAsText(file, 'utf-8');
    });
    document.getElementById('japaneseFileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(evt) {
        window.fullJapLines = evt.target.result.split('\n');
        window.japaneseLines = window.fullJapLines; // для совместимости
        
        // Проверяем, загружен ли русский файл
        if (textBlocks.length === 0) {
          // Если русский файл не загружен, работаем только с японским
          extractJapaneseTextsOnly(window.japaneseLines);
        } else {
          // Если русский файл загружен, работаем как обычно
          extractJapaneseTexts(window.japaneseLines);
        }
        
        updateMatchLamp();
        updateRedIndices();
        // Обновляем видимость кнопок исправления
        if (typeof window.updateFixButtonsVisibility === 'function') {
          window.updateFixButtonsVisibility();
        }
      };
      reader.readAsText(file, 'utf-8');
    });

    function resetJapaneseBlockMapping() {
      let used = new Array(textBlocks.length).fill(false);
      
      for (let j = 0; j < japBlocks.length; j++) {
        const japText = japBlocks[j].text;
        let found = false;
        
        for (let i = 0; i < textBlocks.length; i++) {
          // пропускаем уже использованные, без idx и помеченные как generated
          if (used[i])       { continue; }
          if (textBlocks[i].idx === undefined) { continue; }
          if (textBlocks[i].generated) { continue; }
          // Для ShowText блоков проверяем наличие имени
          if (textBlocks[i].type === 'ShowText') {
            const ruHasName = /<∾∾C\[\d+\]/.test(textBlocks[i].text);
            if (ruHasName === /^【.*】$/.test(japText)) {
              japaneseBlockMapping[j] = i;
              used[i] = true;
              found = true;
              break;
            }
          }
          // Для других типов блоков просто сопоставляем по типу
          else if (japBlocks[j] && japBlocks[j].blockType === textBlocks[i].type) {
            japaneseBlockMapping[j] = i;
            used[i] = true;
            found = true;
            break;
          }
        }
        if (!found) {
          japaneseBlockMapping[j] = -1;
        }
      }
    }

    function moveJapaneseBlock(japIdx, direction) {
      // direction: -1 (вверх), 1 (вниз)
      let current = japaneseBlockMapping[japIdx];
      if (current === -1) return;
      let i = current + direction;
      while (i >= 0 && i < textBlocks.length) {
        // Только главные строки
        if (textBlocks[i].idx !== undefined && !japaneseBlockMapping.includes(i)) {
          japaneseBlockMapping[japIdx] = i;
          renderTextBlocks();
          return;
        }
        i += direction;
      }
    }

    // Универсальная функция для определения, является ли ShowText блоком с именем
    function isNameBlock(text) {
      // Для русского: <∾∾C[6]...∾∾C[0]>
      // Для японского: 【...】
      return /<∾∾C\[6\].*?∾∾C\[0\]>/u.test(text) || /^【.*】$/.test(text);
    }

    // Функция для получения "структурных" блоков
    function getStructureBlocks(blocks) {
      // Только основные типы!
      const allowedTypes = ['ShowText', 'DisplayName', 'ShowChoices', 'When'];
      return blocks
        .filter(b => !b.generated)
        .filter(b => allowedTypes.includes(b.type))
        .map(b => {
          if (b.type === 'ShowText') {
            const isName = isNameBlock(b.text);
            return ['ShowText', isName];
          }
          return [b.type];
        });
    }

    // Вспомогательные функции для визуального выделения несовпадающих блоков
    function highlightStructMismatch(indices) {
      // Сначала убираем все старые выделения
      clearStructMismatchHighlight();
      // Получаем только основные блоки (ShowText, DisplayName, ShowChoices, When, без generated)
      const allowedTypes = ['ShowText', 'DisplayName', 'ShowChoices', 'When'];
      let mainBlocks = window.textBlocks
        .map((b, i) => ({b, i}))
        .filter(obj => !obj.b.generated && allowedTypes.includes(obj.b.type));
      indices.forEach(idx => {
        if (mainBlocks[idx] && mainBlocks[idx].b.dom && mainBlocks[idx].b.dom.rusInput) {
          mainBlocks[idx].b.dom.rusInput.style.outline = '2px solid #f00';
        }
      });
    }

    let mapDisplayName = '';

    window.extractTexts = function() {
      // --- Сначала парсим Display Name ---
      mapDisplayName = '';
      for (let i = 0; i < originalLines.length; i++) {
        const match = originalLines[i].match(/^\s*Display Name\s*=\s*"(.*)"/);
        if (match) {
          mapDisplayName = match[1];
          break;
        }
      }

      const tempBlocks = [];
      const textCmdRegex = /^\s*ShowText\(\["([\s\S]*?)"\]\)/;
      const showChoicesRegex = /^\s*ShowChoices\(\[\[(.*)\],\s*(\d+)\]\)/;
      const whenRegex = /^\s*When\(\[(\d+),\s*"(.*)"\]\)/;
      const otherRegex = /^\s*(\w+)\(\[(.*)\]\)/;

      originalLines.forEach((line, idx) => {
        if (/^\s*Display Name\s*=/.test(line)) return;
        
        let match;
        if ((match = line.match(textCmdRegex))) {
          tempBlocks.push({ text: match[1], type: 'ShowText', originalIdx: idx, line: line });
        } else if ((match = line.match(showChoicesRegex))) {
          let choicesText = match[1];
          let defaultChoice = match[2];
          const choices = choicesText.split('", "').map(c => c.replace(/^"|"$/, ''));
          tempBlocks.push({ text: choices.join(' | '), type: 'ShowChoices', originalIdx: idx, choices: choices, defaultChoice: parseInt(defaultChoice), line: line });
        } else if ((match = line.match(whenRegex))) {
          tempBlocks.push({ text: match[2], type: 'When', originalIdx: idx, choiceIndex: parseInt(match[1]), line: line });
        } else if ((match = line.match(otherRegex))) {
          tempBlocks.push({ text: match[2], type: match[1], originalIdx: idx, line: line });
        }
      });

      window.textBlocks = textBlocks = [];
      
      // === НОВОЕ: Регулярное выражение для распознавания строк о симпатии ===
      const affinityRegex = /^【(.+?)】（好感度：(.*)）$/;

      for (let i = 0; i < tempBlocks.length; i++) {
        const currentBlock = tempBlocks[i];
        const rawText = currentBlock.text.replace(/^"(.*)"$/, '$1');
        let affinityMatch = rawText.match(affinityRegex);

        // === НОВЫЙ БЛОК ЛОГИКИ ===
        if (currentBlock.type === 'ShowText' && affinityMatch) {
          const name = affinityMatch[1];
          const variable = affinityMatch[2].replace(/\\/g, '∾∾'); // Превращаем \V в ∾∾V

          // Собираем строку в нужном для редактора формате
          const newText = `∾\n<∾∾C[6]${name}∾∾C[0]>(Уровень симпатии: ${variable})`;

          textBlocks.push({
            idx: currentBlock.originalIdx,
            text: newText,
            type: 'ShowText',
            generated: /#\+/.test(currentBlock.line),
            manualPlus: /#\+/.test(currentBlock.line) && currentBlock.originalIdx !== undefined
          });

        } else if (currentBlock.type === 'ShowText' && isNameBlock(rawText)) {
          // --- Существующая логика для обычных диалогов с именем (остаётся без изменений) ---
          const dialogueParts = [currentBlock.text];
          let lookahead = i + 1;

          while (lookahead < tempBlocks.length &&
                 tempBlocks[lookahead].type === 'ShowText' &&
                 !isNameBlock(tempBlocks[lookahead].text.replace(/^"(.*)"$/, '$1'))) {
            dialogueParts.push(tempBlocks[lookahead].text);
            lookahead++;
          }
          
          const combinedText = dialogueParts.map(part => part.replace(/^"(.*)"$/, '$1').replace(/\\n/g, '\n').replace(/\\/g, '∾')).join('\n');
          const isGenerated = /#\+/.test(currentBlock.line);

          textBlocks.push({
            idx: currentBlock.originalIdx,
            text: combinedText,
            type: 'ShowText',
            generated: isGenerated,
            manualPlus: /#\+/.test(currentBlock.line) && currentBlock.originalIdx !== undefined
          });

          i = lookahead - 1;
        } else {
          // --- Существующая логика для всех остальных блоков (остаётся без изменений) ---
          const text = currentBlock.text.replace(/^"(.*)"$/, '$1').replace(/\\n/g, '\n').replace(/\\/g, '∾');
          textBlocks.push({
            idx: currentBlock.originalIdx,
            text: (currentBlock.type === 'ShowChoices') ? currentBlock.text : text,
            type: currentBlock.type,
            generated: /#\+/.test(currentBlock.line),
            manualPlus: /#\+/.test(currentBlock.line) && currentBlock.originalIdx !== undefined,
            choices: currentBlock.choices,
            defaultChoice: currentBlock.defaultChoice,
            choiceIndex: currentBlock.choiceIndex
          });
        }
      }
      
      resetJapaneseBlockMapping();
      renderTextBlocks();
    }

    function extractJapaneseTexts(lines) {
      const tempBlocks = [];
      window.japDisplayName = '';
      const textCmdRegex = /^\s*ShowText\(\[\s*"([\s\S]*?)"\s*\]\)/;
      const displayNameRegex = /^\s*Display Name\s*=\s*"(.*)"/;
      const showChoicesRegex = /^\s*ShowChoices\(\[\[(.*)\],\s*(\d+)\]\)/;
      const whenRegex = /^\s*When\(\[(\d+),\s*"(.*)"\]\)/;
      const otherRegex = /^\s*(\w+)\(\[(.*)\]\)/;

      lines.forEach((line, idx) => {
        let match;
        if ((match = line.match(textCmdRegex))) {
          tempBlocks.push({ text: match[1], type: 'ShowText', originalIdx: idx });
        } else if ((match = line.match(displayNameRegex))) {
          window.japDisplayName = match[1];
        } else if ((match = line.match(showChoicesRegex))) {
          const choices = match[1].split('", "').map(c => c.replace(/^"|"$/, ''));
          tempBlocks.push({ text: choices.join(' | '), type: 'ShowChoices', originalIdx: idx, choices: choices });
        } else if ((match = line.match(whenRegex))) {
          tempBlocks.push({ text: match[2], type: 'When', originalIdx: idx, choiceIndex: parseInt(match[1]) });
        } else if ((match = line.match(otherRegex))) {
          tempBlocks.push({ text: match[2], type: match[1], originalIdx: idx });
        }
      });
      
      window.japBlocks = japBlocks = [];
      const nameRegex = /^【.*】$/;
      const affinityRegex = /^【(.+?)】（好感度：(.*)）$/; // То же рег. выражение, что и в extractTexts

      for (let i = 0; i < tempBlocks.length; i++) {
        const currentBlock = tempBlocks[i];
        if (currentBlock.type !== 'ShowText') {
          // Обрабатываем другие типы блоков как есть
          japBlocks.push({
            type: 'no_name',
            text: currentBlock.text,
            blockType: currentBlock.type,
            originalIdx: currentBlock.originalIdx,
            choices: currentBlock.choices,
            choiceIndex: currentBlock.choiceIndex
          });
          continue;
        }

        const rawText = currentBlock.text;
        let affinityMatch = rawText.match(affinityRegex);

        if (affinityMatch) {
          // НАЙДЕНА СТРОКА О СИМПАТИИ - обрабатываем её как особый случай
          const name = affinityMatch[1];
          const restOfText = `（好感度：${affinityMatch[2]}）`;
          japBlocks.push({
            type: 'name',
            text: `【${name}】\n${restOfText}`,
            blockType: 'ShowText'
          });
        } else if (nameRegex.test(rawText)) {
          // НАЙДЕН ОБЫЧНЫЙ БЛОК С ИМЕНЕМ - объединяем только с первой следующей ShowText
          const name = rawText;
          if (
            i + 1 < tempBlocks.length &&
            tempBlocks[i + 1].type === 'ShowText' &&
            !nameRegex.test(tempBlocks[i + 1].text)
          ) {
            // Объединяем имя и первую реплику
            japBlocks.push({
              type: 'name',
              text: `${name}\n${tempBlocks[i + 1].text}`,
              blockType: 'ShowText'
            });
            i++; // пропускаем первую реплику
          } else {
            // Только имя, без реплики (редко, но возможно)
            japBlocks.push({
              type: 'name',
              text: name,
              blockType: 'ShowText'
            });
          }
        } else {
          // Это обычная реплика без имени
          japBlocks.push({ type: 'no_name', text: rawText, blockType: 'ShowText' });
        }
      }
      linkAndRender();
    }

    // Новая функция для работы только с японским файлом
    function extractJapaneseTextsOnly(lines) {
      window.japDisplayName = '';
      window.originalJapLines = lines.slice();
      
      const tempBlocks = [];
      const textCmdRegex = /^\s*ShowText\(\[\s*"([\s\S]*?)"\s*\]\)/;
      const displayNameRegex = /^\s*Display Name\s*=\s*"(.*)"/;
      const showChoicesRegex = /^\s*ShowChoices\(\[\[(.*)\],\s*(\d+)\]\)/;
      const whenRegex = /^\s*When\(\[(\d+),\s*"(.*)"\]\)/;
      const scriptJpRegex = /^\s*Script\(\[(.*)\]\)/;
      const scriptMoreJpRegex = /^\s*ScriptMore\(\[(.*)\]\)/;
      const showTextAttrRegex = /^\s*ShowTextAttributes\(\[(.*)\]\)/;

      lines.forEach((line, idx) => {
        let match;
        if ((match = line.match(textCmdRegex))) {
          tempBlocks.push({ text: match[1], type: 'ShowText', originalIdx: idx });
        } else if ((match = line.match(displayNameRegex))) {
          // DisplayName обрабатывается отдельно
          window.japDisplayName = match[1];
        } else if ((match = line.match(showChoicesRegex))) {
          const choicesText = match[1];
          const choices = choicesText.split('", "').map(choice => 
            choice.replace(/^"/, '').replace(/"$/, '')
          );
          tempBlocks.push({ 
            text: choices.join(' | '), 
            type: 'ShowChoices', 
            originalIdx: idx,
            choices: choices
          });
        } else if ((match = line.match(whenRegex))) {
          tempBlocks.push({ 
            text: match[2], 
            type: 'When', 
            originalIdx: idx,
            choiceIndex: parseInt(match[1])
          });
        } else if ((match = line.match(scriptJpRegex))) {
          tempBlocks.push({ 
            text: match[1], 
            type: 'Script', 
            originalIdx: idx
          });
        } else if ((match = line.match(scriptMoreJpRegex))) {
          tempBlocks.push({ 
            text: match[1], 
            type: 'ScriptMore', 
            originalIdx: idx
          });
        } else if ((match = line.match(showTextAttrRegex))) {
          tempBlocks.push({ 
            text: match[1], 
            type: 'ShowTextAttributes', 
            originalIdx: idx
          });
        } else {
          // Сохраняем информацию о структурных строках
          tempBlocks.push({ type: 'Structural', text: line, originalIdx: idx });
        }
      });
      
      window.textBlocks = textBlocks = [];
      const nameRegex = /^【.*】$/;
      
      for (let i = 0; i < tempBlocks.length; i++) {
        const currentBlock = tempBlocks[i];

        if (currentBlock.type === 'ShowText' && nameRegex.test(currentBlock.text)) {
          // Это блок с именем. Собираем все последующие строки диалога.
          const dialogueParts = [];
          const nameMatch = currentBlock.text.match(/^【(.*)】$/);
          const name = nameMatch ? nameMatch[1] : '';
          
          let lookahead = i + 1;
          while (lookahead < tempBlocks.length && 
                 tempBlocks[lookahead].type === 'ShowText' && 
                 !nameRegex.test(tempBlocks[lookahead].text)) {
            dialogueParts.push(tempBlocks[lookahead].text);
            lookahead++;
          }
          
          // Создаем один textBlock для всего диалога
          const combinedText = `∾\n<∾∾C[6]${name}∾∾C[0]>${dialogueParts.join('\n')}`;
          const originalJapText = `【${name}】\n${dialogueParts.join('\n')}`;

          textBlocks.push({
            idx: currentBlock.originalIdx,
            text: combinedText,
            type: 'ShowText',
            generated: false,
            japaneseLink: { type: 'name', text: originalJapText },
            // Сохраняем, сколько строк мы объединили, чтобы пропустить их при сохранении
            linesToSkip: dialogueParts.length,
            // Сохраняем части диалога для правильного сохранения
            dialogueParts: dialogueParts
          });

          i = lookahead - 1; // Пропускаем уже обработанные блоки
        } else if (currentBlock.type === 'ShowText') {
           // Это обычный ShowText без имени
           textBlocks.push({
             idx: currentBlock.originalIdx,
             text: currentBlock.text,
             type: 'ShowText',
             generated: false,
             japaneseLink: { type: 'no_name', text: currentBlock.text }
           });
        } else if (currentBlock.type !== 'Structural') {
          // Обрабатываем другие типы блоков
          textBlocks.push({
            idx: currentBlock.originalIdx,
            text: currentBlock.text,
            type: currentBlock.type,
            generated: false,
            japaneseLink: { type: 'no_name', text: currentBlock.text },
            choices: currentBlock.choices,
            choiceIndex: currentBlock.choiceIndex
          });
        }
      }
      
      // Находим и устанавливаем DisplayName для редактора
      const dnMatch = lines.join('\n').match(/^\s*Display Name\s*=\s*"(.*)"/m);
      if (dnMatch) {
          mapDisplayName = dnMatch[1];
          window.japDisplayName = dnMatch[1];
      }
      
      renderTextBlocks();
    }

    function reorderTextBlocksByJapBlocks() {
      // Заглушка: логика будет реализована позже
    }

    function linkAndRender() {
      textBlocks.forEach(block => { delete block.japaneseLink; });
      japaneseBlockMapping = new Array(japBlocks.length).fill(-1);
      manualJapaneseMapping = []; // Сброс ручных привязок при перезагрузке

      // --- собираем только «основные» (оригинальные) русские блоки, у которых idx !== undefined
      const rusMainIndices = textBlocks.reduce((arr, b, i) => {
        if (b.idx !== undefined && !b.generated) arr.push(i);
        return arr;
      }, []);
      const rusMainBlocks = rusMainIndices.map(i => textBlocks[i]);

      if (textBlocks.length === 0 || japBlocks.length === 0) {
        renderTextBlocks();
        return;
      }
      
      // Если все блоки без idx (режим работы только с японским файлом), пропускаем привязку
      if (textBlocks.every(block => block.idx === undefined)) {
        renderTextBlocks();
        return;
      }
      let rusLinked = new Array(textBlocks.length).fill(false);

      // 1. ПРИОРИТЕТНАЯ ПРИВЯЗКА ДЛЯ НЕ-ShowText БЛОКОВ, пропуская все сгенерированные
      const blockTypesToMatch = ['DisplayName', 'ShowChoices', 'When', 'Script', 'ScriptMore', 'JumpToLabel', 'Label'];
      blockTypesToMatch.forEach(type => {
        const japIndices = japBlocks.map((b, i) => b.blockType === type ? i : -1).filter(i => i !== -1);
        const rusMainTypeIndices = rusMainBlocks
          .map((b, j) => b.type === type ? j : -1)
          .filter(j => j !== -1);
        const rusIndices = rusMainTypeIndices.map(j => rusMainIndices[j]);
        const len = Math.min(japIndices.length, rusIndices.length);
        for (let k = 0; k < len; k++) {
          const japIdx = japIndices[k];
          const realRusIdx = rusIndices[k];
          if (typeof realRusIdx === 'number'
              && textBlocks[realRusIdx]
              && !textBlocks[realRusIdx].generated
              && japaneseBlockMapping[japIdx] === -1
              && !rusLinked[realRusIdx]) {
            if (type === 'When' && textBlocks[realRusIdx].choiceIndex !== japBlocks[japIdx].choiceIndex) continue;
            textBlocks[realRusIdx].japaneseLink = { type: 'no_name', text: japBlocks[japIdx].text };
            japaneseBlockMapping[japIdx] = realRusIdx;
            rusLinked[realRusIdx] = true;
          }
        }
      });

      // 2. СЕГМЕНТАЦИЯ И ПРИВЯЗКА ShowText БЛОКОВ
      let japNameIndices = [-1];
      japBlocks.forEach((b, i) => {
        if (b.blockType === 'ShowText' && b.type === 'name') japNameIndices.push(i);
      });
      japNameIndices.push(japBlocks.length);

      // Аналогично — только по оригинальным русским блокам:
      let rusMainNameIndices = [-1];
      rusMainBlocks.forEach((b, j) => {
        if (b.type === 'ShowText' && isNameBlock(b.text)) rusMainNameIndices.push(j);
      });
      rusMainNameIndices.push(rusMainBlocks.length);

      // 2.1. Привязка блоков с именами (опять же — skip generated)
      for (let i = 1; i < japNameIndices.length - 1; i++) {
        const japIdx = japNameIndices[i];
        const rusMainIdx = rusMainNameIndices[i];
        if (Number.isInteger(rusMainIdx) && rusMainIdx >= 0 && rusMainIdx < rusMainIndices.length) {
          const realRusIdx = rusMainIndices[rusMainIdx];
          if (realRusIdx !== undefined
              && textBlocks[realRusIdx]
              && !textBlocks[realRusIdx].generated
              && !rusLinked[realRusIdx]) {
            textBlocks[realRusIdx].japaneseLink = { type: 'name', text: japBlocks[japIdx].text };
            japaneseBlockMapping[japIdx] = realRusIdx;
            rusLinked[realRusIdx] = true;
          }
        }
      }

      // 2.2. Привязка блоков без имен внутри сегментов
      for (let seg = 0; seg < japNameIndices.length - 1; seg++) {
        let japStart = japNameIndices[seg] + 1;
        let japEnd = japNameIndices[seg + 1];
        let rusMainStart = (rusMainNameIndices[seg] !== undefined ? rusMainNameIndices[seg] : -1) + 1;
        let rusMainEnd = rusMainNameIndices[seg + 1] !== undefined ? rusMainNameIndices[seg + 1] : rusMainBlocks.length;

        let japNoNameIndices = [];
        for (let j = japStart; j < japEnd; j++) {
          if (japBlocks[j].blockType === 'ShowText' && japBlocks[j].type === 'no_name' && japaneseBlockMapping[j] === -1) {
            japNoNameIndices.push(j);
          }
        }

        let rusMainNoNameIndices = [];
        for (let r = rusMainStart; r < rusMainEnd; r++) {
          if (rusMainBlocks[r].type === 'ShowText' && !isNameBlock(rusMainBlocks[r].text) && !rusLinked[rusMainIndices[r]]) {
            rusMainNoNameIndices.push(r);
          }
        }

        const len = Math.min(japNoNameIndices.length, rusMainNoNameIndices.length);
        for (let k = 0; k < len; k++) {
          const japIdx = japNoNameIndices[k];
          const rusMainNoNameIdx = rusMainNoNameIndices[k];
          if (Number.isInteger(rusMainNoNameIdx) && rusMainNoNameIdx >= 0 && rusMainNoNameIdx < rusMainIndices.length) {
            const realRusIdx = rusMainIndices[rusMainNoNameIdx];
            if (realRusIdx !== undefined
                && textBlocks[realRusIdx]
                && !textBlocks[realRusIdx].generated) {
              textBlocks[realRusIdx].japaneseLink = { type: 'no_name', text: japBlocks[japIdx].text };
              japaneseBlockMapping[japIdx] = realRusIdx;
              rusLinked[realRusIdx] = true;
            }
          }
        }
      }
      // 3. ОБРАБОТКА ОСТАВШИХСЯ ЯПОНСКИХ БЛОКОВ (если для них не нашлось русского)
      for (let j = 0; j < japBlocks.length; j++) {
        if (japaneseBlockMapping[j] === -1) {
          let insertAt = textBlocks.length;
          for (let prev = j - 1; prev >= 0; prev--) {
            if (japaneseBlockMapping[prev] !== -1) {
              insertAt = japaneseBlockMapping[prev] + 1;
              break;
            }
          }
          const newBlock = {
            idx: undefined,
            text: 'ТРЕБУЕТСЯ ПЕРЕВОД',
            type: japBlocks[j].blockType || 'ShowText',
            generated: true
          };
          textBlocks.splice(insertAt, 0, newBlock);
          newBlock.japaneseLink = { type: japBlocks[j].type, text: japBlocks[j].text };
          japaneseBlockMapping[j] = insertAt;
          for (let k = 0; k < japaneseBlockMapping.length; k++) {
            if (k !== j && japaneseBlockMapping[k] >= insertAt) {
              japaneseBlockMapping[k]++;
            }
          }
        }
      }
      // --- после всех сопоставлений ---
      reorderTextBlocksByJapBlocks();
      // --- ДОБАВЛЕНО: сохраняем все Script/ScriptMore без японского аналога ---
      textBlocks.forEach(block => {
        if ((block.type === 'Script' || block.type === 'ScriptMore') && !block.japaneseLink) {
          block.japaneseLink = { type: 'no_name', text: '' };
        }
      });
      renderTextBlocks();
    }

    function pushUndo() {
      undoStack.push({
        textBlocks: JSON.parse(JSON.stringify(textBlocks)),
        mapDisplayName: mapDisplayName,
        selections: getSelections()
      });
      if (undoStack.length > MAX_HISTORY) undoStack.shift();
      redoStack = [];
    }

    function renderTextBlocks() {
      const editor = document.getElementById('editor');
      editor.innerHTML = '';
      document.getElementById('undoBtn').disabled = undoStack.length === 0;
      document.getElementById('redoBtn').disabled = redoStack.length === 0;
      document.getElementById('saveBtn').style.display = textBlocks.length > 0 ? '' : 'none';
      document.getElementById('copyBtn').style.display = textBlocks.length > 0 ? '' : 'none';

      if (textBlocks.length === 0) {
        editor.innerHTML = '<p>Загрузите файл для перевода.</p>';
        return;
      }
      
      // --- Display Name сверху ---
      const displayDiv = document.createElement('div');
      displayDiv.style.marginBottom = '18px';
      const label = document.createElement('label');
      label.textContent = 'Display Name:';
      label.style.fontWeight = 'bold';
      label.style.marginRight = '8px';
      const input = document.createElement('input');
      input.type = 'text';
      input.id = 'mapDisplayName';
      input.value = mapDisplayName;
      input.style.width = '60%';
      input.style.fontSize = '16px';
      input.style.padding = '4px 8px';
      input.style.marginLeft = '8px';
      input.addEventListener('input', function() {
        mapDisplayName = this.value;
      });
      displayDiv.appendChild(label);
      displayDiv.appendChild(input);
      // --- Показываем японский Display Name для справки ---
      if (window.japDisplayName) {
        const jpSpan = document.createElement('span');
        jpSpan.style.color = '#888';
        jpSpan.style.marginLeft = '10px';
        jpSpan.textContent = ` (JP: ${window.japDisplayName})`;
        displayDiv.appendChild(jpSpan);
      }
      editor.appendChild(displayDiv);
      
      textBlocks.forEach((block, i) => {
        // Показываем только текстовые типы данных
        if (block.type !== 'ShowText' && block.type !== 'ShowChoices' && block.type !== 'When' && block.type !== 'JumpToLabel' && block.type !== 'ScriptMore' && block.type !== 'Label' && block.type !== 'Script') return;
        
        // Для Script: показываем, если либо в тексте блока, либо в его japaneseLink.text есть японские символы
        if (block.type === 'Script') {
          const hasJapanese = /[ぁ-んァ-ン一-龯]/.test(block.text);
          const hasJapaneseInOriginal = block.japaneseLink && /[ぁ-んァ-ン一-龯]/.test(block.japaneseLink.text || '');
          const hasRussian = /[А-Яа-яЁё]/.test(block.text);
          if (hasRussian) {
            // Если есть русские буквы — всегда показываем
          } else if (!hasJapanese && !hasJapaneseInOriginal) return;
        }
        // Для ScriptMore: показываем, если есть русские или японские символы либо в тексте, либо в оригинале
        if (block.type === 'ScriptMore') {
          const hasJapanese = /[ぁ-んァ-ン一-龯]/.test(block.text);
          const hasJapaneseInOriginal = block.japaneseLink && /[ぁ-んァ-ン一-龯]/.test(block.japaneseLink.text || '');
          const hasRussian = /[А-Яа-яЁё]/.test(block.text);
          if (!hasRussian && !hasJapanese && !hasJapaneseInOriginal) return;
        }

        // Не отображаем ShowTextAttributes в редакторе
        if (block.type === 'ShowTextAttributes') return;
        // Не отображаем Display Name в редакторе (он обрабатывается отдельно сверху)
        if (block.type === 'DisplayName') return;
        const div = document.createElement('div');
        div.className = 'block';
        const label = document.createElement('label');
        
        // Создаем заголовок в зависимости от типа блока
        if (block.idx !== undefined) {
          switch (block.type) {
            case 'ShowText':
              label.textContent = `ShowText [строка ${block.idx+1}]:`;
              break;
            case 'DisplayName':
              label.textContent = `Display Name [строка ${block.idx+1}]:`;
              break;
            case 'ShowChoices':
              label.textContent = `ShowChoices [строка ${block.idx+1}]:`;
              break;
            case 'When':
              label.textContent = `When [строка ${block.idx+1}]:`;
              break;
            case 'JumpToLabel':
              label.textContent = `JumpToLabel [строка ${block.idx+1}]:`;
              break;
            case 'Label':
              label.textContent = `Label [строка ${block.idx+1}]:`;
              break;
            case 'ScriptMore':
              label.textContent = `ScriptMore [строка ${block.idx+1}]:`;
              break;
            case 'Script':
              label.textContent = `Script [строка ${block.idx+1}]:`;
              break;
            case 'ScriptMore':
              label.textContent = `ScriptMore [строка ${block.idx+1}]:`;
              break;
            case 'ShowTextAttributes':
              label.textContent = `ShowTextAttributes [строка ${block.idx+1}]:`;
              break;
            default:
              label.textContent = `[строка ${block.idx+1}]:`;
          }
        } else {
          label.textContent = '[продолжение]:';
        }
        div.appendChild(label);

        // Показываем японский блок для всех типов строк
        if (block.japaneseLink) {
          let japaneseText = block.japaneseLink.text;
          
          // Если это режим работы только с японским файлом, преобразуем имена
          if (textBlocks.length > 0 && textBlocks[0].idx === undefined) {
            // Преобразуем формат ∾\n<∾∾C[6]Имя∾∾C[0]> обратно в 【Имя】 для отображения
            japaneseText = japaneseText.replace(/∾\n<∾∾C\[6\](.*?)∾∾C\[0\]>/g, '【$1】\n');
          }
          
          const pre = document.createElement('pre');
          pre.className = 'japanese-original';
          pre.textContent = japaneseText.replace(/\\n/g, '\n');
          div.appendChild(pre);
        }

        const textarea = document.createElement('textarea');
        textarea.value = block.text;
        // вешаем слушатели, чтобы активировать кнопку при выделении
        textarea.addEventListener('select',  updateWrapBtn);
        textarea.addEventListener('keyup',   updateWrapBtn);
        textarea.addEventListener('mouseup', updateWrapBtn);
        textarea.addEventListener('blur',    updateWrapBtn);
        textarea.setAttribute('data-block', i);
        div.appendChild(textarea);

        // --- Сохраняем ссылку на textarea для дубликат-логики ---
        block.dom = block.dom || {};
        block.dom.rusInput = textarea;

        const counter = document.createElement('div');
        counter.style.fontSize = '12px';
        counter.style.color = '#888';
        counter.style.margin = '2px 0 6px 0';
        div.appendChild(counter);

        const plusBtn = document.createElement('button');
        const minusBtn = document.createElement('button');
        
        div.appendChild(document.createElement('br'));
        div.appendChild(plusBtn);
        div.appendChild(minusBtn);
        
        // --- Расширенная обработка дубликатов японского текста ---
        if (block.type === 'ShowText' && block.japaneseLink && block.japaneseLink.text) {
          try {
            const currentJap = block.japaneseLink.text.trim();
            // ищем индекс оригинала, без выхода из функции
            const origIdx = textBlocks.findIndex((b, idx2) =>
              idx2 < i &&
              b.japaneseLink &&
              b.japaneseLink.text.trim() === currentJap
            );
            // если оригинал не найден, просто пропускаем логику дубликата
            if (origIdx !== -1) {
              const rusInputEl = block.dom && block.dom.rusInput;
              if (rusInputEl) {
                const dupBtn = document.createElement('button');
                dupBtn.textContent = 'Дубликат';
                dupBtn.title = `Повтор строки ${textBlocks[origIdx].idx + 1}`;
                dupBtn.style.marginLeft = '8px';
                div.appendChild(dupBtn);

                // Функция для получения объединённого текста (в одну строку)
                const collectText = start => {
                  let end = start + 1;
                  while (
                    end < textBlocks.length &&
                    textBlocks[end].type === 'ShowText' &&
                    (!textBlocks[end].japaneseLink || !textBlocks[end].japaneseLink.text.trim())
                  ) end++;
                  return textBlocks.slice(start, end)
                    .map(b => b.dom?.rusInput?.value.trim() || '')
                    .filter(v => v)
                    .join(' ');
                };

                // Функция для получения счётчика символов блока
                const getCharCount = blockIdx => {
                  const block = textBlocks[blockIdx];
                  if (!block || !block.dom?.rusInput) return 0;

                  const text = block.dom.rusInput.value;
                  if (block.type === 'ShowText' || block.type === undefined) {
                    const info = getGameTextInfo(text);

                    // 1) Убираем «полные» теги <∾∾C[...]>…∾∾C[...]>
                    // 2) Убираем оставшиеся коды ∾∾C[...]
                    // 3) Убираем остаточные C[...] (на случай, если «∾» уже срезаны)
                    // 4) Убираем одиночные символы-разделители ∾
                    const visibleText = info.rawGameText
                      .replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '')
                      .replace(/∾∾C\[\d+\]/g, '')
                      .replace(/C\[\d+\]/g, '')
                      .replace(/∾/g, '')
                      .replace(/∿/g, '')
                      .trim();

                    return visibleText.length;
                  } else {
                    // Для других типов блоков просто убираем «∾»
                    return text.replace(/∾/g, '').length;
                  }
                };

                // Получаем счётчики символов
                const origCount = getCharCount(origIdx);
                const currCount = getCharCount(i);

                // Функция обновления цвета кнопки
                const updateDupStyle = () => {
                  const origText = collectText(origIdx);
                  const currText = collectText(i);
                  const newOrigCount = getCharCount(origIdx);
                  const newCurrCount = getCharCount(i);
                  
                  // Зеленая, если текст совпадает или счётчики символов равны
                  if (currText === origText || newCurrCount === newOrigCount) {
                    dupBtn.style.backgroundColor = '#8f8';
                  } else {
                    dupBtn.style.backgroundColor = '#f88';
                  }
                };

                // Клик: вставить объединённый текст
                dupBtn.addEventListener('click', () => {
                  const origText = collectText(origIdx);
                  rusInputEl.value = origText;
                  rusInputEl.dispatchEvent(new Event('input', { bubbles: true }));
                  updateDupStyle();
                });

                // Слушатели изменений на всех связанных ShowText
                const attachListeners = start => {
                  let end = start + 1;
                  while (
                    end < textBlocks.length &&
                    textBlocks[end].type === 'ShowText' &&
                    (!textBlocks[end].japaneseLink || !textBlocks[end].japaneseLink.text.trim())
                  ) end++;
                  for (let k = start; k < end; k++) {
                    textBlocks[k].dom?.rusInput?.addEventListener('input', updateDupStyle);
                  }
                };
                attachListeners(origIdx);
                attachListeners(i);

                // Инициализация цвета
                updateDupStyle();
              }
            }
          } catch (e) {
            // console.error('Ошибка обработки дубликата на строке', block.idx + 1, e);
          }
        }
        
        function updateAll() {
          window.updateAllForBlock(block, textarea, plusBtn, minusBtn, counter, textBlocks);
        }
        
        textarea.addEventListener('input', function() {
          pushUndo();
          // --- Сохраняем старое значение до обновления ---
          const oldText = textBlocks[i].text;
          // ---
          textBlocks[i].text = textarea.value;
          updateAll();

          // --- АВТОМАТИЧЕСКОЕ ОБНОВЛЕНИЕ ИМЕНИ ПЕРСОНАЖА ---
          // Проверяем, есть ли тег <∾∾C[6]...∾∾C[0]> и японское имя над блоком
          const nameTagMatch = textarea.value.match(/<∾∾C\[6\](.*?)∾∾C\[0\]>/);
          if (block.japaneseLink && block.japaneseLink.type === 'name' && nameTagMatch) {
            const newRuName = nameTagMatch[1];
            const japName = block.japaneseLink.text.split('\n')[0].trim();
            // Получаем старое имя из старого значения
            const prevNameTagMatch = oldText.match(/<∾∾C\[6\](.*?)∾∾C\[0\]>/);
            const prevRuName = prevNameTagMatch ? prevNameTagMatch[1] : null;
            // Если имя не изменилось — ничего не делаем
            if (prevRuName === newRuName) return;
            // Проходим по всем ShowText с тем же японским именем
            for (let j = 0; j < textBlocks.length; j++) {
              if (j === i) continue; // не трогаем текущий
              const b = textBlocks[j];
              if (b.type === 'ShowText' && b.japaneseLink && b.japaneseLink.type === 'name') {
                const bJapName = b.japaneseLink.text.split('\n')[0].trim();
                if (bJapName === japName) {
                  // Меняем имя только если оно отличается
                  b.text = b.text.replace(/(<∾∾C\[6\]).*?(∾∾C\[0\]>)/, `$1${newRuName}$2`);
                  // Если textarea уже отрисована — обновляем её значение
                  if (b.dom && b.dom.rusInput) {
                    b.dom.rusInput.value = b.text;
                  }
                }
              }
            }
            // renderTextBlocks(); // Больше не вызываем, чтобы не сбивалась прокрутка
          }

          // --- АВТОМАТИЧЕСКОЕ ОБНОВЛЕНИЕ JUMPTOLABEL ---
          if (block.type === 'JumpToLabel' && block.japaneseLink && block.japaneseLink.text) {
            const newRuLabel = textarea.value.trim();
            const japLabel = block.japaneseLink.text.trim();
            // Получаем старое значение
            const prevRuLabel = oldText.trim();
            // Если значение не изменилось — ничего не делаем
            if (prevRuLabel === newRuLabel) return;
            // Проходим по всем JumpToLabel с тем же японским текстом
            for (let j = 0; j < textBlocks.length; j++) {
              if (j === i) continue; // не трогаем текущий
              const b = textBlocks[j];
              if (b.type === 'JumpToLabel' && b.japaneseLink && b.japaneseLink.text) {
                const bJapLabel = b.japaneseLink.text.trim();
                if (bJapLabel === japLabel) {
                  // Меняем значение только если оно отличается
                  b.text = newRuLabel;
                  // Если textarea уже отрисована — обновляем её значение
                  if (b.dom && b.dom.rusInput) {
                    b.dom.rusInput.value = b.text;
                  }
                }
              }
            }
            // --- СВЯЗЬ JUMPTOLABEL С LABEL ---
            // Также обновляем все Label с тем же японским текстом
            for (let j = 0; j < textBlocks.length; j++) {
              if (j === i) continue; // не трогаем текущий
              const b = textBlocks[j];
              if (b.type === 'Label' && b.japaneseLink && b.japaneseLink.text) {
                const bJapLabel = b.japaneseLink.text.trim();
                if (bJapLabel === japLabel) {
                  // Меняем значение только если оно отличается
                  b.text = newRuLabel;
                  // Если textarea уже отрисована — обновляем её значение
                  if (b.dom && b.dom.rusInput) {
                    b.dom.rusInput.value = b.text;
                  }
                }
              }
            }
          }

          // --- АВТОМАТИЧЕСКОЕ ОБНОВЛЕНИЕ LABEL ---
          if (block.type === 'Label' && block.japaneseLink && block.japaneseLink.text) {
            const newRuLabel = textarea.value.trim();
            const japLabel = block.japaneseLink.text.trim();
            // Получаем старое значение
            const prevRuLabel = oldText.trim();
            // Если значение не изменилось — ничего не делаем
            if (prevRuLabel === newRuLabel) return;
            // Проходим по всем Label с тем же японским текстом
            for (let j = 0; j < textBlocks.length; j++) {
              if (j === i) continue; // не трогаем текущий
              const b = textBlocks[j];
              if (b.type === 'Label' && b.japaneseLink && b.japaneseLink.text) {
                const bJapLabel = b.japaneseLink.text.trim();
                if (bJapLabel === japLabel) {
                  // Меняем значение только если оно отличается
                  b.text = newRuLabel;
                  // Если textarea уже отрисована — обновляем её значение
                  if (b.dom && b.dom.rusInput) {
                    b.dom.rusInput.value = b.text;
                  }
                }
              }
            }
            // --- СВЯЗЬ LABEL С JUMPTOLABEL ---
            // Также обновляем все JumpToLabel с тем же японским текстом
            for (let j = 0; j < textBlocks.length; j++) {
              if (j === i) continue; // не трогаем текущий
              const b = textBlocks[j];
              if (b.type === 'JumpToLabel' && b.japaneseLink && b.japaneseLink.text) {
                const bJapLabel = b.japaneseLink.text.trim();
                if (bJapLabel === japLabel) {
                  // Меняем значение только если оно отличается
                  b.text = newRuLabel;
                  // Если textarea уже отрисована — обновляем её значение
                  if (b.dom && b.dom.rusInput) {
                    b.dom.rusInput.value = b.text;
                  }
                }
              }
            }
          }

          // --- АВТОМАТИЧЕСКОЕ ОБНОВЛЕНИЕ SCRIPTMORE ---
          if (block.type === 'ScriptMore' && block.japaneseLink && block.japaneseLink.text) {
            const newRuScript = textarea.value.trim();
            const japScript = block.japaneseLink.text.trim();
            // Получаем старое значение
            const prevRuScript = oldText.trim();
            // Если значение не изменилось — ничего не делаем
            if (prevRuScript === newRuScript) return;
            // Проходим по всем ScriptMore с тем же японским текстом
            for (let j = 0; j < textBlocks.length; j++) {
              if (j === i) continue; // не трогаем текущий
              const b = textBlocks[j];
              if (b.type === 'ScriptMore' && b.japaneseLink && b.japaneseLink.text) {
                const bJapScript = b.japaneseLink.text.trim();
                if (bJapScript === japScript) {
                  // Меняем значение только если оно отличается
                  b.text = newRuScript;
                  // Если textarea уже отрисована — обновляем её значение
                  if (b.dom && b.dom.rusInput) {
                    b.dom.rusInput.value = b.text;
                  }
                }
              }
            }
          }

          // --- АВТОМАТИЧЕСКОЕ ОБНОВЛЕНИЕ SCRIPT ---
          if (block.type === 'Script' && block.japaneseLink && block.japaneseLink.text) {
            const newRuScript = textarea.value.trim();
            const japScript = block.japaneseLink.text.trim();
            // Получаем старое значение
            const prevRuScript = oldText.trim();
            // Если значение не изменилось — ничего не делаем
            if (prevRuScript === newRuScript) return;
            // Проходим по всем Script с тем же японским текстом
            for (let j = 0; j < textBlocks.length; j++) {
              if (j === i) continue; // не трогаем текущий
              const b = textBlocks[j];
              if (b.type === 'Script' && b.japaneseLink && b.japaneseLink.text) {
                const bJapScript = b.japaneseLink.text.trim();
                if (bJapScript === japScript) {
                  // Меняем значение только если оно отличается
                  b.text = newRuScript;
                  // Если textarea уже отрисована — обновляем её значение
                  if (b.dom && b.dom.rusInput) {
                    b.dom.rusInput.value = b.text;
                  }
                }
              }
            }
          }
        });
        textarea.addEventListener('keydown', function(e) {
          if (e.ctrlKey && (e.key === 'z' || e.key === 'Z')) {
            e.preventDefault(); document.getElementById('undoBtn').click();
          }
          if (e.ctrlKey && (e.key === 'y' || e.key === 'Y')) {
            e.preventDefault(); document.getElementById('redoBtn').click();
          }
        });
        textarea.addEventListener('select', updateAll);
        
        plusBtn.textContent = '+';
        plusBtn.style.marginTop = '4px';
        plusBtn.onclick = function() {
          saveEditorBlockPosition(); // Сохраняем позицию до изменений
          pushUndo();
          const info = getGameTextInfo(textarea.value);
          let namePart = info.fullPrefix;
          let textPart = info.rawGameText;
          let acc = '';
          let rest = '';

          // Логика разделения текста (остается без изменений)
          if (wrapMode === 'equal') {
            const totalLen = textPart.length;
            const midPoint = Math.floor(totalLen / 2);
            let splitIndex = textPart.lastIndexOf(' ', midPoint);
            if (splitIndex === -1) { splitIndex = textPart.indexOf(' ', midPoint); }
            if (splitIndex === -1) {
                acc = textPart;
                rest = '';
            } else {
                acc = textPart.substring(0, splitIndex);
                rest = textPart.substring(splitIndex + 1);
            }
          } else { 
            const words = textPart.split(' ');
            let firstLineWords = [];
            for (const word of words) {
                firstLineWords.push(word);
                if (firstLineWords.join(' ').replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '').replace(/∾/g, '').length > 50) {
                    firstLineWords.pop();
                    break;
                }
            }
            acc = firstLineWords.join(' ');
            rest = words.slice(firstLineWords.length).join(' ');
          }

          // В первую строку — namePart + acc, во вторую — только rest (без namePart)
          textarea.value = namePart + acc.trimEnd();
          textBlocks[i].text = textarea.value;

          // --- Новый механизм разбиения окна ---
          // 1. Находим начало текущего "окна" (индекс последнего ShowTextAttributes)
          let windowStartIndex = 0;
          for (let j = i - 1; j >= 0; j--) {
            if (textBlocks[j].type === 'ShowTextAttributes') {
              windowStartIndex = j + 1;
              break;
            }
          }
          // 2. Считаем строки ShowText в текущем окне до текущего блока
          let linesInWindow = 0;
          for (let j = windowStartIndex; j <= i; j++) {
            if (textBlocks[j].type === 'ShowText' || textBlocks[j].type === undefined) {
              linesInWindow++;
            }
          }
          // 3. Если мы разделяем 4-ю строку, нужно вставить ShowTextAttributes
          if (linesInWindow >= 4 && rest.trim() !== '') {
            // Найти текст последнего атрибута для копирования
            let attrText = '["",0,0,2]';
            for (let j = i; j >= 0; j--) {
              if (textBlocks[j].type === 'ShowTextAttributes') {
                attrText = textBlocks[j].text;
                break;
              }
            }
            // Вставляем новый ShowTextAttributes, а затем новую строку ShowText
            textBlocks.splice(i + 1, 0, { type: 'ShowTextAttributes', text: attrText, idx: undefined, generated: true });
            textBlocks.splice(i + 2, 0, { text: rest.trimStart(), type: 'ShowText', idx: undefined, generated: true });
          } else {
            // В противном случае, просто добавляем новую строку как продолжение
            textBlocks.splice(i + 1, 0, { text: rest.trimStart(), type: 'ShowText', idx: undefined, generated: true });
          }
          renderTextBlocks();
          restoreEditorBlockPosition(); // Восстанавливаем позицию после перерисовки
        };
        
        minusBtn.textContent = '-';
        minusBtn.style.marginLeft = '8px';
        // --- Всегда показываем кнопку для manualPlus ---
        minusBtn.style.display = (block.manualPlus || (block.text.trim() === '' && textBlocks.length > 1)) ? '' : 'none';
        minusBtn.onclick = function() {
          saveEditorBlockPosition(); // Сохраняем позицию до изменений
          pushUndo();
          // Если manualPlus — просто удаляем
          if (block.manualPlus) {
            textBlocks.splice(i, 1);
            renderTextBlocks();
            restoreEditorBlockPosition(); // Восстанавливаем позицию после перерисовки
            return;
          }
          // Если предыдущий блок — ShowTextAttributes и это первая ShowText после него, удаляем оба
          if (i > 0 && textBlocks[i].type === 'ShowText' && textBlocks[i - 1].type === 'ShowTextAttributes') {
            textBlocks.splice(i - 1, 2);
            renderTextBlocks();
            restoreEditorBlockPosition(); // Восстанавливаем позицию после перерисовки
            return;
          }
          textBlocks.splice(i, 1);
          renderTextBlocks();
          restoreEditorBlockPosition(); // Восстанавливаем позицию после перерисовки
        };
        
        updateAll();
        editor.appendChild(div);
      });

      // после полной отрисовки — пересчитаем красные строки и включим/выключим стрелки
      updateRedIndices();
      // --- Повторно блокируем saveBtn, если есть красные строки (на случай, если updateRedIndices не вызвался) --- 
      const saveBtn = document.getElementById('saveBtn');
      if (saveBtn) {
        // Если активирован режим восстановления структуры, разблокируем кнопку
        if (window.restoreModeEnabled) {
          saveBtn.disabled = false;
          saveBtn.style.background = '#cdf'; // Голубой фон для обозначения режима восстановления
          saveBtn.style.color = '#333';
          saveBtn.title = 'Структура восстановлена. Можно сохранить файл.';
        } else {
          // Обычная логика блокировки
          saveBtn.disabled = false;
          if (redIndices.length > 0) {
            saveBtn.style.background = '#ffd6d6';
            saveBtn.style.color = '#a00';
            saveBtn.title = 'Есть неисправленные красные строки (ошибка или японский текст)! Исправьте ошибки перед сохранением.';
          } else {
            saveBtn.style.background = '';
            saveBtn.style.color = '';
            saveBtn.title = '';
          }
        }
      }
    }

    // === Функция экранирования первых трёх управляющих последовательностей ===
    function escapeFirstThree(str) {
      let count = 0;
      let result = str.replace(/\\n|<\\?C\[6\]|\\?C\[0\]>/g, function(match) {
        count++;
        if (count === 1 && match === '\\n') return '\\\\n';
        if (count === 2 && (match === '<\\C[6]' || match === '<C[6]')) return '<\\\\C[6]';
        if (count === 3 && (match === '\\C[0]>' || match === 'C[0]>')) return '\\\\C[0]>';
        return match;
      });
      return result;
    }

    // === Счётчик предупреждений для кнопки сохранения ===
    if (typeof window.saveWarnCounter === 'undefined') window.saveWarnCounter = 0;

    document.getElementById('saveBtn').onclick = function() {
      // Проверяем наличие красных строк через глобальный массив redIndices
      const hasRed = window.redIndices && window.redIndices.length > 0;
      if (hasRed) {
        window.saveWarnCounter = (window.saveWarnCounter || 0) + 1;
        if (window.saveWarnCounter % 2 === 1) {
          alert('Внимание! Не все красные строки исправлены. Продолжайте только если уверены.');
          return;
        }
      }
      document.querySelectorAll('textarea[data-block]').forEach(ta => {
        const i = +ta.dataset.block;
        if(textBlocks[i]) textBlocks[i].text = ta.value;
      });
      let exportLines;
      if (window.restoreModeEnabled && window.japaneseLines && window.originalLines) {
        // Если восстановление уже было выполнено, используем обновленные строки
        exportLines = window.fullRusLines.slice();
      } else if (!originalLines || originalLines.length === 0) {
        // Режим работы только с японским файлом
        if (window.originalJapLines && window.originalJapLines.length > 0) {
            // --- НОВЫЙ, НАДЕЖНЫЙ АЛГОРИТМ СБОРКИ ФАЙЛА ---
            exportLines = [];
            const blockMap = new Map();
            textBlocks.forEach(block => {
                if (block.idx !== undefined) {
                    blockMap.set(block.idx, block);
                }
            });

            for (let i = 0; i < window.originalJapLines.length; i++) {
                const currentLine = window.originalJapLines[i];
                const block = blockMap.get(i);

                if (block) {
                    // Эта строка была обработана и есть в textBlocks.
                    const indentMatch = currentLine.match(/^\s*/);
                    const indent = indentMatch ? indentMatch[0] : '';
                    
                                      if (block.type === 'ShowText' && block.japaneseLink && block.japaneseLink.type === 'name') {
                      // Это блок с именем. Восстанавливаем оригинальную структуру.
                      const nameMatch = block.text.match(/∾\n<∾∾C\[6\](.*?)∾∾C\[0\]>/);
                      if (nameMatch) {
                          const name = nameMatch[1];
                          
                          // Проверяем, есть ли у нас сохраненные части диалога
                          if (block.dialogueParts && block.dialogueParts.length > 0) {
                                                             // Сначала добавляем строку с именем и первой частью диалога
                               const firstPart = block.dialogueParts[0];
                               let txt = firstPart.replace(/∿/g, '<<ONE>>').replace(/∾+/g, '\\\\').replace(/<<ONE>>/g, '\\').replace(/(?<!\\)"/g, '\\"');
                               exportLines.push(`${indent}ShowText(["\\\\n<\\\\C[6]${name}\\\\C[0]>${txt}"])`);
                              
                              // Затем добавляем остальные части диалога как отдельные строки
                              for (let j = 1; j < block.dialogueParts.length; j++) {
                                  const part = block.dialogueParts[j];
                                  if (part.trim()) {
                                      let txt = part.replace(/∿/g, '<<ONE>>').replace(/∾+/g, '\\\\').replace(/<<ONE>>/g, '\\').replace(/(?<!\\)"/g, '\\"');
                                      exportLines.push(`${indent}ShowText(["${txt}"])`);
                                  }
                              }
                          } else {
                              // Fallback: используем старый метод
                              const cleanText = block.text.replace(/∾<∾∾C\[6\].*?∾∾C\[0\]>/, '');
                              const linesToSave = cleanText.split('\n');
                              
                              linesToSave.forEach(line => {
                                  if (line.trim()) {
                                      let txt = line.replace(/∿/g, '<<ONE>>').replace(/∾+/g, '\\\\').replace(/<<ONE>>/g, '\\').replace(/(?<!\\)"/g, '\\"');
                                      exportLines.push(`${indent}ShowText(["${txt}"])`);
                                  }
                              });
                          }
                      }
                      
                      // Пропускаем оригинальные строки, которые были объединены
                      if (block.linesToSkip) {
                          i += block.linesToSkip;
                      }
                    } else if (block.type === 'ShowText') {
                        // Обычный ShowText без имени
                        let txt = block.text.replace(/∿/g, '<<ONE>>');
                        txt = txt.replace(/\n/g, '\\n');
                        
                        // --- НАЧАЛО ИСПРАВЛЕНИЯ ---
                        // Сначала заменяем двойные ∾∾ на двойные слэши \\
                        txt = txt.replace(/∾∾/g, '\\\\'); 
                        // Затем заменяем оставшиеся одиночные ∾ на одиночные слэши \
                        txt = txt.replace(/∾/g, '\\');
                        // --- КОНЕЦ ИСПРАВЛЕНИЯ ---
                        
                        txt = txt.replace(/<<ONE>>/g, '\\');
                        txt = txt.replace(/\\(?=[\?\.!\,—])/g, '');
                        let newText = txt.replace(/(?<!\\)"/g, '\\"');
                        
                        // --- Применяем escapeFirstThree только к строкам с именем ---
                        if (/^\\n<\\C\[6\].*?\\C\[0\]>/.test(newText)) {
                          newText = escapeFirstThree(newText);
                        }
                        // --- Исправление: двойной слэш для спецсимволов уровня симпатии ---
                        newText = newText.replace(/\\V\[/g, '\\\\V[');
                        newLine = originalLine.replace(/\[(.*)\]/, `["${newText}"]`);
                        break;
                    } else {
                        // Другие типы блоков (ShowChoices, When, Script и т.д.)
                        let formattedLine = '';
                        switch (block.type) {
                            case 'ShowChoices':
                                const choices = block.text.split(' | ');
                                const choicesFormatted = choices.map(choice => 
                                    `"${choice.replace(/∾/g, '\\').replace(/"/g, '\\"')}"`
                                ).join(', ');
                                formattedLine = `${indent}ShowChoices([[${choicesFormatted}], ${block.defaultChoice || 0}])`;
                                break;
                            case 'When':
                                const whenText = block.text.replace(/∾/g, '\\').replace(/"/g, '\\"');
                                formattedLine = `${indent}When([${block.choiceIndex || 0}, "${whenText}"])`;
                                break;
                            case 'JumpToLabel':
                                const jumpToLabelText = block.text.replace(/∾/g, '\\').replace(/"/g, '\\"');
                                formattedLine = `${indent}JumpToLabel(["${jumpToLabelText}"])`;
                                break;
                            case 'Label':
                                const labelText = block.text.replace(/∾/g, '\\').replace(/"/g, '\\"');
                                formattedLine = `${indent}Label(["${labelText}"])`;
                                break;
                            case 'Script':
                                const scriptText = block.text.replace(/∾/g, '\\');
                                formattedLine = `${indent}Script(["${scriptText}"])`;
                                break;
                            case 'ScriptMore':
                                const scriptMoreText = block.text.replace(/∾/g, '\\');
                                formattedLine = `${indent}ScriptMore(["${scriptMoreText}"])`;
                                break;
                            default:
                                formattedLine = `${indent}${block.type}([${block.text}])`;
                        }
                        exportLines.push(formattedLine);
                    }
                } else {
                    // Эта строка - структурная (ConditionalBranch, Empty и т.д.) или была пропущена при парсинге.
                    // Просто добавляем ее как есть, но проверяем на Display Name.
                    if (/^\s*Display Name\s*=/.test(currentLine)) {
                       exportLines.push(`Display Name = "${mapDisplayName}"`);
                    } else {
                       exportLines.push(currentLine);
                    }
                }
            }
        } else {
           alert("Нет данных для сохранения!");
           return;
        }
      } else {
        let newLines = [...originalLines];
        let lineInsertOffset = 0;
        let blockIndexMap = new Map();
        let displayNameLine = `Display Name = "${mapDisplayName}"`;
        let foundDisplayName = false;
        for (let i = 0; i < newLines.length; i++) {
          if (/^\s*Display Name\s*=/.test(newLines[i])) {
            newLines[i] = displayNameLine;
            foundDisplayName = true;
            break;
          }
        }
        if (!foundDisplayName) {
          newLines.unshift(displayNameLine);
        }
        textBlocks.forEach((block, blockIndex) => {
          if (block.idx !== undefined) {
            const originalLine = originalLines[block.idx];
            const indentMatch = originalLine.match(/^\s*/);
            const indent = indentMatch ? indentMatch[0] : '';
            let newLine;
            switch (block.type) {
              case 'ShowText':
                let txt = block.text.replace(/∿/g, '<<ONE>>');
                txt = txt.replace(/\n/g, '\\n');
                
                // --- НАЧАЛО ИСПРАВЛЕНИЯ ---
                // Сначала заменяем двойные ∾∾ на двойные слэши \\
                txt = txt.replace(/∾∾/g, '\\\\'); 
                // Затем заменяем оставшиеся одиночные ∾ на одиночные слэши \
                txt = txt.replace(/∾/g, '\\');
                // --- КОНЕЦ ИСПРАВЛЕНИЯ ---
                
                txt = txt.replace(/<<ONE>>/g, '\\');
                txt = txt.replace(/\\(?=[\?\.!\,—])/g, '');
                let newText = txt.replace(/(?<!\\)"/g, '\\"');
                
                // --- Применяем escapeFirstThree только к строкам с именем ---
                if (/^\\n<\\C\[6\].*?\\C\[0\]>/.test(newText)) {
                  newText = escapeFirstThree(newText);
                }
                // --- Исправление: двойной слэш для спецсимволов уровня симпатии ---
                newText = newText.replace(/\\V\[/g, '\\\\V[');
                newLine = originalLine.replace(/\[(.*)\]/, `["${newText}"]`);
                break;
              case 'ShowTextAttributes':
                newLine = originalLine.replace(/\[(.*)\]/, `[${block.text}]`);
                break;
              case 'DisplayName':
                const displayText = block.text.replace(/∾/g, '\\').replace(/"/g, '\\"');
                newLine = originalLine.replace(/"(.*)"/, `"${displayText}"`);
                break;
              case 'ShowChoices':
                const choices = block.text.split(' | ');
                const choicesFormatted = choices.map(choice => 
                  `"${choice.replace(/∾/g, '\\').replace(/"/g, '\\"')}"`
                ).join(', ');
                newLine = originalLine.replace(/\[\[(.*)\],\s*(\d+)\]/, `[[${choicesFormatted}], ${block.defaultChoice || 0}]`);
                break;
              case 'When':
                const whenText = block.text.replace(/∾/g, '\\').replace(/"/g, '\\"');
                newLine = originalLine.replace(/\[(\d+),\s*"(.*)"\]/, `[${block.choiceIndex || 0}, "${whenText}"]`);
                break;
              case 'JumpToLabel':
                const jumpToLabelText = block.text.replace(/∾/g, '\\').replace(/"/g, '\\"');
                newLine = originalLine.replace(/\[(.*)\]/, `["${jumpToLabelText}"]`);
                break;
              case 'Label':
                const labelText = block.text.replace(/∾/g, '\\').replace(/"/g, '\\"');
                newLine = originalLine.replace(/\[(.*)\]/, `["${labelText}"]`);
                break;
              case 'Script':
                const scriptText = block.text.replace(/∾/g, '\\');
                newLine = originalLine.replace(/\[(.*)\]/, `["${scriptText}"]`);
                break;
              case 'ScriptMore':
                const scriptMoreText = block.text.replace(/∾/g, '\\');
                newLine = originalLine.replace(/\[(.*)\]/, `["${scriptMoreText}"]`);
                break;
              default:
                newLine = originalLine;
            }
            newLines[block.idx + lineInsertOffset] = indent + newLine.trimStart();
            blockIndexMap.set(blockIndex, block.idx + lineInsertOffset);
          } else {
            // --- ЛОГИРОВАНИЕ: обработка блока [продолжение]: ---
            // console.log(`[LOG] Обработка блока [продолжение]:`, block);
            let lastMainBlockIdx = -1;
            for (let j = blockIndex - 1; j >= 0; j--) {
              if (textBlocks[j].idx !== undefined) {
                lastMainBlockIdx = textBlocks[j].idx;
                break;
              }
            }
            let indent = '';
            if (lastMainBlockIdx !== -1) {
              const originalLine = originalLines[lastMainBlockIdx];
              const indentMatch = originalLine.match(/^\s*/);
              indent = indentMatch ? indentMatch[0] : '';
            }
            if (block.type === 'ShowTextAttributes') {
              // Пропускаем блоки с "ТРЕБУЕТСЯ ПЕРЕВОД" - они не должны сохраняться
              if (block.text !== 'ТРЕБУЕТСЯ ПЕРЕВОД') {
                let lineToInsert = indent + `ShowTextAttributes([${block.text}])`;
                if (block.generated) {
                  lineToInsert += ' #+';
                }
                newLines.splice(lastMainBlockIdx + 1 + lineInsertOffset, 0, lineToInsert);
                lineInsertOffset++;
                blockIndexMap.set(blockIndex, lastMainBlockIdx + 1 + lineInsertOffset - 1);
              }
            } else if (/^\\n<\\C\[6\]/.test(block.text)) {
              // Пропускаем блоки с "ТРЕБУЕТСЯ ПЕРЕВОД"
              if (block.text !== 'ТРЕБУЕТСЯ ПЕРЕВОД') {
                let lineToInsert = indent + `ShowText(["${block.text}"])`;
                if (block.type === 'ShowText' && block.generated) {
                  lineToInsert += ' #+';
                }
                newLines.splice(lastMainBlockIdx + 1 + lineInsertOffset, 0, lineToInsert);
                lineInsertOffset++;
                blockIndexMap.set(blockIndex, lastMainBlockIdx + 1 + lineInsertOffset - 1);
              }
            } else {
              // Пропускаем блоки с "ТРЕБУЕТСЯ ПЕРЕВОД"
              if (block.text !== 'ТРЕБУЕТСЯ ПЕРЕВОД') {
                let cont = block.text.replace(/∿/g, '<<ONE>>');
                cont = cont.replace(/\n/g, '\\n');
                cont = cont.replace(/∾+/g, '\\');
                cont = cont.replace(/<<ONE>>/g, '\\');
                cont = cont.replace(/\\{2,}n/g, '\\\\n');
                cont = cont.replace(/\\(?=[\?\.!\,—])/g, '');
                let newText = cont.replace(/(?<!\\)"/g, '\\"');
                let lineToInsert = indent + `ShowText(["${newText}"])`;
                if (block.type === 'ShowText' && block.generated) {
                  lineToInsert += ' #+';
                }
                newLines.splice(lastMainBlockIdx + 1 + lineInsertOffset, 0, lineToInsert);
                lineInsertOffset++;
                blockIndexMap.set(blockIndex, lastMainBlockIdx + 1 + lineInsertOffset - 1);
              }
            }
          }
        });
        // --- ЛОГИРОВАНИЕ: после обработки textBlocks ---
        // console.log('[LOG] newLines после обработки textBlocks:', newLines);
        

        
        // --- Функция форматирования текста для экспорта (exportFormat) ---
        function exportFormat(text) {
          let cont = text.replace(/∿/g, '<<ONE>>');
          cont = cont.replace(/\n/g, '\\n');
          cont = cont.replace(/∾+/g, '\\');
          cont = cont.replace(/<<ONE>>/g, '\\');
          cont = cont.replace(/\\{2,}n/g, '\\\\n');
          cont = cont.replace(/\\(?=[\?\.!\,—])/g, '');
          let newText = cont.replace(/(?<!\\)"/g, '\\"');
          return newText;
        }
        // --- Общая функция фильтрации exportLines ---
        function getExportLines(newLines, textBlocks) {
          return newLines.filter((line, idx) => {
            if (/ShowText\(\[".*"\]\)\s*#\+/.test(line)) {
              const lineText = line.match(/ShowText\(\["(.*)"\]\)/)?.[1];
              const found = textBlocks.find(b =>
                b.type === 'ShowText' &&
                b.generated &&
                exportFormat(b.text) === lineText
              );
              return !!found;
            }
            return true;
          });
        }
        // --- Новый фильтр для exportLines по решению.txt ---
        exportLines = getExportLines(newLines, textBlocks);
      }
      // --- ЛОГИРОВАНИЕ: итоговый exportLines ---
      // console.log('[LOG] Итоговый exportLines:', exportLines);
      // --- остальной код сохранения ---
      let saveName = 'Map001_edited.txt';
      if (loadedFileName) {
        const dotIdx = loadedFileName.lastIndexOf('.');
        if (dotIdx !== -1) {
          saveName = loadedFileName.slice(0, dotIdx) + '_edited' + loadedFileName.slice(dotIdx);
        } else {
          saveName = loadedFileName + '_edited.txt';
        }
      } else if (window.originalJapLines && window.originalJapLines.length > 0) {
        // Если загружен только японский файл, используем имя из Display Name
        saveName = `${mapDisplayName || 'Map001'}_translated.txt`;
      }
      

      
      const blob = new Blob([exportLines.join('\n')], {type: 'text/plain'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = saveName;
      a.click();
    };

    document.getElementById('copyBtn').onclick = function() {
      let outputLines = [];

      // === 1. Добавляем Display Name в начало ===
      if (typeof mapDisplayName !== 'undefined') {
        let label = '[Display Name]: ';
        outputLines.push(label + mapDisplayName);
      }

      // === 2. Проходим по всем блокам из редактора ===
      for (let i = 0; i < textBlocks.length; i++) {
        const block = textBlocks[i];

        // Показываем только текстовые типы данных (как в редакторе)
        if (block.type !== 'ShowText' && block.type !== 'ShowChoices' && block.type !== 'When' && block.type !== 'JumpToLabel' && block.type !== 'ScriptMore' && block.type !== 'Label' && block.type !== 'Script') {
          continue;
        }

        // Пропускаем типы, которые не нужно копировать
        const skippableTypes = ['ShowTextAttributes', 'DisplayName'];
        if (skippableTypes.includes(block.type)) {
          continue;
        }
        
        // Для Script и ScriptMore копируем только те, которые содержат японские символы
        if ((block.type === 'Script' || block.type === 'ScriptMore') && !/[ぁ-んァ-ン一-龯]/.test(block.text)) {
          continue;
        }

        // Формируем метку (например, "[ShowText строка 140]: ")
        let label = '';
        if (block.idx !== undefined) {
          let typeLabel = block.type || 'Unknown';
          if (typeLabel === 'ShowChoices') typeLabel = 'ShowChoices';
          if (typeLabel === 'When') typeLabel = 'When';
          if (typeLabel === 'ShowText') typeLabel = 'ShowText';

          label = `[${typeLabel} строка ${block.idx + 1}]: `;
        } else {
          label = '[продолжение]: ';
        }

        // === 3. Просто добавляем текст блока, как он есть, без склеивания ===
        // Мы используем .split('\n') на случай, если в одном блоке всё же окажется несколько строк
        const textParts = block.text.split('\n');
        for(let k = 0; k < textParts.length; k++) {
            if (k === 0) {
                // Первую строку добавляем с меткой
                outputLines.push(label + textParts[k]);
            } else {
                // Последующие строки (если они есть) добавляем без метки
                outputLines.push(textParts[k]);
            }
        }
      }

      // === 4. Собираем и копируем результат ===
      // Используем двойной перенос строки между логическими блоками для читаемости
      const copyText = outputLines.join('\n\n');
      navigator.clipboard.writeText(copyText).then(() => {
        alert('Текст скопирован в буфер обмена!');
      }, () => {
        alert('Ошибка копирования!');
      });
    };
    
    document.getElementById('wrapModeBtn').onclick = function() {
        const btn = this;
        if (wrapMode === 'remainder') {
            wrapMode = 'equal';
            btn.textContent = 'Режим переноса: Равный';
            btn.title = 'Переносится примерно половина слов';
        } else {
            wrapMode = 'remainder';
            btn.textContent = 'Режим переноса: Остаточный';
            btn.title = 'Переносятся только слова, не вмещающиеся в лимит';
        }
    };
    document.getElementById('wrapModeBtn').title = 'Переносятся только слова, не вмещающиеся в лимит';

    // Кнопка "Разделить Строки": корректная массовая обработка без появления пустых строк
    document.getElementById('splitAllBtn').onclick = function() {
      let i = 0;
      while (i < textBlocks.length) {
        const block = textBlocks[i];
        if (block.type === 'ShowText' && block.text && block.text.trim().length > 0 && !block.generated) {
          const info = getGameTextInfo(block.text);
          let namePart = info.fullPrefix;
          let textPart = info.rawGameText;
          let acc = '';
          let rest = '';
          if (wrapMode === 'equal') {
            const totalLen = textPart.length;
            let midPoint = Math.floor(totalLen / 2);
            let splitIndex = textPart.lastIndexOf(' ', midPoint);
            if (splitIndex === -1) { splitIndex = textPart.indexOf(' ', midPoint); }
            if (splitIndex === -1) {
                acc = textPart;
                rest = '';
            } else {
                acc = textPart.substring(0, splitIndex);
                rest = textPart.substring(splitIndex + 1);
            }
          } else {
            const words = textPart.split(' ');
            let firstLineWords = [];
            for (const word of words) {
                firstLineWords.push(word);
                if (firstLineWords.join(' ').replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '').replace(/∾/g, '').length > 50) {
                    firstLineWords.pop();
                    break;
                }
            }
            acc = firstLineWords.join(' ');
            rest = words.slice(firstLineWords.length).join(' ');
          }
          textBlocks[i].text = namePart + acc.trimEnd();
          // --- механизм разбиения окна ---
          let windowStartIndex = 0;
          for (let j = i - 1; j >= 0; j--) {
            if (textBlocks[j].type === 'ShowTextAttributes') {
              windowStartIndex = j + 1;
              break;
            }
          }
          let linesInWindow = 0;
          for (let j = windowStartIndex; j <= i; j++) {
            if (textBlocks[j].type === 'ShowText' || textBlocks[j].type === undefined) {
              linesInWindow++;
            }
          }
          if (linesInWindow >= 4 && rest.trim() !== '') {
            let attrText = '["",0,0,2]';
            for (let j = i; j >= 0; j--) {
              if (textBlocks[j].type === 'ShowTextAttributes') {
                attrText = textBlocks[j].text;
                break;
              }
            }
            textBlocks.splice(i + 1, 0, { type: 'ShowTextAttributes', text: attrText, idx: undefined, generated: true });
            textBlocks.splice(i + 2, 0, { text: rest.trimStart(), type: 'ShowText', idx: undefined, generated: true });
            i += 2;
          } else if (rest.trim() !== '') {
            textBlocks.splice(i + 1, 0, { text: rest.trimStart(), type: 'ShowText', idx: undefined, generated: true });
            i += 1;
          }
        }
        i++;
      }
      renderTextBlocks();
    };

    // Собирает актуальный список индексов красных textarea
    function updateRedIndices() {
      // Собираем индексы всех ошибочных строк (по длине, синтаксису и японскому тексту)
      window.redIndices = redIndices = [];
      textBlocks.forEach((block, i) => {
        const ta = block.dom?.rusInput;
        if (!ta) return;
        let isError = false;
        // Проверка на превышение длины
        if ((block.type === 'ShowText' || block.type === undefined)) {
          const info = window.getGameTextInfo(block.text);
          const visibleText = info.rawGameText
            .replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '')
            .replace(/∾∾C\[\d+\]/g, '')
            .replace(/C\[\d+\]/g, '')
            .replace(/∾/g, '')
            .replace(/∿/g, '')
            .trim();
          if (visibleText.length > 50) isError = true;
          if (info.isCorrupted) isError = true;
        }
        // Проверка на японский текст
        if (/[\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF]/.test(block.text)) isError = true;
        if (isError) redIndices.push(i);
      });
      // Окрашиваем все textarea с ошибками
      textBlocks.forEach((block, i) => {
        const ta = block.dom?.rusInput;
        if (!ta) return;
        if (redIndices.includes(i)) {
          ta.style.backgroundColor = '#ffd6d6';
        } else {
          ta.style.backgroundColor = '';
        }
      });
      // Если после пересчёта указатель ушёл за пределы — сбросим
      if (redPointer >= redIndices.length) redPointer = -1;

      // --- управление отключением кнопок ---
      const prev = document.getElementById('prevRedBtn');
      const next = document.getElementById('nextRedBtn');
      const disabled = redIndices.length === 0;
      prev.disabled = disabled;
      next.disabled = disabled;

      // --- Блокировка кнопки сохранения, если есть красные строки ---
      const saveBtn = document.getElementById('saveBtn');
      if (saveBtn) {
        // Если активирован режим восстановления структуры, разблокируем кнопку
        if (window.restoreModeEnabled) {
          saveBtn.disabled = false;
          saveBtn.style.background = '#cdf'; // Голубой фон для обозначения режима восстановления
          saveBtn.style.color = '#333';
          saveBtn.title = 'Структура восстановлена. Можно сохранить файл.';
        } else {
          // Обычная логика блокировки
          saveBtn.disabled = false;
          if (redIndices.length > 0) {
            saveBtn.style.background = '#ffd6d6';
            saveBtn.style.color = '#a00';
            saveBtn.title = 'Есть неисправленные красные строки (ошибка или японский текст)! Исправьте ошибки перед сохранением.';
          } else {
            saveBtn.style.background = '';
            saveBtn.style.color = '';
            saveBtn.title = '';
          }
        }
      }
      
      // Обновляем видимость кнопок исправления
      if (typeof window.updateFixButtonsVisibility === 'function') {
        window.updateFixButtonsVisibility();
      }
    }

    function moveToNextRed() {
      updateRedIndices();
      if (redIndices.length === 0) return;
      // переходим к следующему, с циклом
      redPointer = (redPointer + 1) % redIndices.length;
      const idx = redIndices[redPointer];
      const ta = document.querySelector(`textarea[data-block='${idx}']`);
      ta.scrollIntoView({behavior:'smooth', block:'center'});
      ta.focus();
    }

    function moveToPrevRed() {
      updateRedIndices();
      if (redIndices.length === 0) return;
      // если ещё ни разу не двигались назад — ставим в конец
      if (redPointer < 0) redPointer = 0;
      redPointer = (redPointer - 1 + redIndices.length) % redIndices.length;
      const idx = redIndices[redPointer];
      const ta = document.querySelector(`textarea[data-block='${idx}']`);
      ta.scrollIntoView({behavior:'smooth', block:'center'});
      ta.focus();
    }

    // Привязываем кнопки
    document.getElementById('nextRedBtn').onclick = moveToNextRed;
    document.getElementById('prevRedBtn').onclick = moveToPrevRed;

    // Инициализируем состояние стрелок при загрузке
    updateRedIndices();

    // === Обработчик кнопки восстановления структуры ===
    document.getElementById('restoreStructBtn').onclick = function() {
      if (typeof window.immediateRestoreStructure === 'function') {
        window.immediateRestoreStructure();
      } else {
        window.restoreModeEnabled = true;
        alert("Жёсткий режим восстановления структуры активирован.\nИзменения CommonEvent будут применены только при сохранении!");
      }
    };

    // === Обработчик кнопки исправления ошибок Script ===
    document.getElementById('fixScriptBtn').onclick = function() {
      if (typeof window.autoFixScriptErrors === 'function') {
        window.autoFixScriptErrors();
      } else {
        alert("Функция исправления ошибок Script недоступна!");
      }
    };

    // === Обработчик кнопки исправления отступов ===
    document.getElementById('fixIndentBtn').onclick = function() {
      if (typeof window.autoFixIndentErrors === 'function') {
        window.autoFixIndentErrors();
      } else {
        alert("Функция исправления отступов недоступна!");
      }
    };

    document.addEventListener('DOMContentLoaded', function() {
      // Перемещаем editor внутрь tabContentEditor только один раз
      var editorDiv = document.getElementById('editor');
      var tabContentEditor = document.getElementById('tabContentEditor');
      if (editorDiv && tabContentEditor && editorDiv.parentNode !== tabContentEditor) {
        tabContentEditor.appendChild(editorDiv);
      }
    });

    // === Обновление списка ошибок под предпросмотром ===
    window.updatePreviewErrors = function() {
      const diffsDiv = document.getElementById('previewDiffs');
      let html = '';
      // 1. Ошибки по лимиту символов и синтаксису
      if (!window.textBlocks || window.textBlocks.length === 0) {
        diffsDiv.innerHTML = '';
        return;
      }
      const errors = [];
      window.textBlocks.forEach((block, i) => {
        if (block.type === 'ShowText' || block.type === undefined) {
          const info = window.getGameTextInfo(block.text);
          const visibleText = info.rawGameText
            .replace(/<∾∾C\[\d+\](?:.*?)∾∾C\[\d+\]>/g, '')
            .replace(/∾∾C\[\d+\]/g, '')
            .replace(/C\[\d+\]/g, '')
            .replace(/∾/g, '')
            .replace(/∿/g, '')
            .trim();
          const len = visibleText.length;
          if (len > 50) {
            errors.push({
              idx: block.idx,
              label: block.idx !== undefined ? `строка ${block.idx+1}` : '[продолжение]',
              type: 'ShowText',
              reason: `Превышен лимит символов: ${len} > 50`
            });
          }
          if (info.isCorrupted) {
            errors.push({
              idx: block.idx,
              label: block.idx !== undefined ? `строка ${block.idx+1}` : '[продолжение]',
              type: 'ShowText',
              reason: 'Повреждён тег имени (<∾∾C[6]...∾∾C[0]>) или синтаксис строки'
            });
          }
          // --- Ошибка: наличие японского текста ---
          if (/[\u3040-\u30FF\u3400-\u4DBF\u4E00-\u9FFF]/.test(block.text)) {
            errors.push({
              idx: block.idx,
              label: block.idx !== undefined ? `строка ${block.idx+1}` : '[продолжение]',
              type: block.type || 'ShowText',
              reason: 'Обнаружен японский текст в поле ввода'
            });
          }
        }
      });
      if (errors.length > 0) {
        html += '<b>Ошибки в строках:</b><ul style="color:#b00; margin-top:4px;">';
      errors.forEach(err => {
        html += `<li><b>${err.label}</b> (${err.type}): ${err.reason}</li>`;
      });
        html += '</ul><hr style="margin:10px 0;">';
      }
      // 2. Статистика сопоставления структуры (группированный вывод)
      if (window.fullRusLines && window.fullJapLines && window.fullRusLines.length > 0 && window.fullJapLines.length > 0 && window.checkMapStructureMatch) {
        const jpContent = window.fullJapLines.join('\n');
        const ruContent = window.fullRusLines.join('\n');
        const result = window.checkMapStructureMatch(jpContent, ruContent);
        result.grouped.forEach(ev => {
          ev.pages.forEach(page => {
            if (page.ok) {
              html += `<div style='color:#228B22; font-weight:bold; margin:6px 0 2px 0;'>CommonEvent ${ev.eid} (${ev.name}), Page ${page.page}: OK</div>`;
            } else {
              html += `<div style='color:#b00; font-weight:bold; margin:10px 0 2px 0;'>CommonEvent ${ev.eid} (${ev.name}), Page ${page.page}</div>`;
              page.errors.forEach(err => {
                // --- Добавляем номер BranchEnd если он есть ---
                const branchEndInfo = err.branchEndNumber !== undefined ? `<div style='color:#666; font-size:12px; margin-bottom:2px;'>BranchEnd ${err.branchEndNumber}</div>` : '';
                html += `<div style='color:#b00; margin-left:12px; margin-bottom:8px;'>${branchEndInfo}<b>Строка ${err.line}:</b> ${err.msg}<br>`;
                if (err.jp || err.ru) {
                  html += `<div style='font-size:13px; margin-top:2px;'><span style='color:#444;'>JP:</span> <pre style='display:inline; background:#f7f7f7; border-radius:4px; padding:2px 6px;'>${(err.jp||'').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</pre><br><span style='color:#444;'>RU:</span> <pre style='display:inline; background:#f7f7f7; border-radius:4px; padding:2px 6px;'>${(err.ru||'').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</pre></div>`;
                }
                html += `</div>`;
              });
            }
          });
        });
        if (result.grouped.length === 0) {
          html += '<span style="color:#393">Структура CommonEvent полностью совпадает.</span>';
        }
      }
      diffsDiv.innerHTML = html;
    };

    // === Управление прокруткой редактора ===
    // let editorScrollTop = 0;
    // function saveEditorScroll() {
    //   const editorDiv = document.getElementById('editor');
    //   if (editorDiv) {
    //     editorScrollTop = editorDiv.scrollTop;
    //   }
    // }
    // function restoreEditorScroll() {
    //   const editorDiv = document.getElementById('editor');
    //   if (editorDiv) {
    //     setTimeout(() => {
    //       editorDiv.scrollTop = editorScrollTop || 0;
    //     }, 0);
    //   }
    // }
    
    // === Сохранение и восстановление позиции по scroll страницы ===
    window.editorScrollPosition = 0;
    function saveEditorBlockPosition() {
      const editorDiv = document.getElementById('editor');
      const tabContentEditor = document.getElementById('tabContentEditor');
      // Проверяем, что вкладка редактора видима
      if (tabContentEditor.style.display === 'none') {
        return;
      }
      // Сохраняем позицию прокрутки окна браузера
      window.editorScrollPosition = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
    }
    function restoreEditorBlockPosition() {
      const editorDiv = document.getElementById('editor');
      const savedPosition = window.editorScrollPosition || 0;
      // Прокручиваем окно браузера
      window.scrollTo(0, savedPosition);
    }

    // Универсальный обработчик вкладок
    function showTab(tab) {
      // Если уходим с редактора — сохраняем позицию страницы
      if (document.getElementById('tabContentEditor').style.display !== 'none' && tab !== 'editor') {
        saveEditorBlockPosition();
      }
      document.getElementById('tabContentEditor').style.display = (tab === 'editor') ? '' : 'none';
      document.getElementById('tabContentPreview').style.display = (tab === 'preview') ? '' : 'none';
      document.getElementById('tabContentBatch').style.display = (tab === 'batch') ? '' : 'none';
      document.getElementById('tabEditor').style.fontWeight = (tab === 'editor') ? 'bold' : 'normal';
      document.getElementById('tabPreview').style.fontWeight = (tab === 'preview') ? 'bold' : 'normal';
      document.getElementById('tabBatch').style.fontWeight = (tab === 'batch') ? 'bold' : 'normal';
      var fileInputsDiv = document.querySelector('.file-inputs');
      if (fileInputsDiv) {
        fileInputsDiv.style.display = (tab === 'batch') ? 'none' : '';
      }
      if (tab !== 'batch') {
        document.getElementById('batchFileList').innerHTML = '';
      }
      // Если пришли на редактор — восстанавливаем позицию страницы
      if (tab === 'editor') {
        setTimeout(restoreEditorBlockPosition, 0);
      }
      // Если пришли на предпросмотр — обновляем предпросмотр
      if (tab === 'preview' && typeof window.updatePreviewArea === 'function') {
        window.updatePreviewArea();
      }
    }
    
    // Следим за прокруткой редактора и привязываем обработчики
    document.addEventListener('DOMContentLoaded', function() {
      const editorDiv = document.getElementById('editor');
      if (editorDiv) {
        editorDiv.addEventListener('scroll', function() {
          editorScrollTop = editorDiv.scrollTop;
        });
      }
      // Привязываем только один обработчик для каждой вкладки
      document.getElementById('tabEditor').onclick = () => showTab('editor');
      document.getElementById('tabPreview').onclick = () => showTab('preview');
      document.getElementById('tabBatch').onclick = () => showTab('batch');
    });

    // === Функция для синхронизации редактора с восстановленными строками ===
    window.syncEditorWithRestored = function() {
      if (!window.fullRusLines || window.fullRusLines.length === 0) {
        console.warn('Нет восстановленных строк для синхронизации');
        return;
      }
      // Сохраняем текущую позицию прокрутки
      const currentScrollPosition = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop;
      // Обновляем originalLines восстановленными строками
      window.originalLines = window.fullRusLines.slice();
      originalLines = window.fullRusLines.slice();
      // Сброс состояния undo/redo
      undoStack = [];
      redoStack = [];
      // ИСПРАВЛЕНИЕ: Сохраняем японские данные перед обновлением
      const hasJapanese = window.fullJapLines && window.fullJapLines.length > 0;
      // Перезапускаем парсинг текста с новыми строками
      window.extractTexts();
      // ИСПРАВЛЕНИЕ: Если были японские блоки, полностью переинициализируем их
      if (hasJapanese) {
        extractJapaneseTexts(window.fullJapLines);
      } else {
        renderTextBlocks();
      }
      // Обновляем лампочку совпадения
      window.updateMatchLamp();
      // Обновляем индексы красных строк
      if (typeof updateRedIndices === 'function') {
        updateRedIndices();
      }
      // Обновляем предпросмотр если он открыт
      if (typeof window.updatePreviewArea === 'function') {
        window.updatePreviewArea();
      }
      // Восстанавливаем позицию прокрутки
      setTimeout(() => {
        window.scrollTo(0, currentScrollPosition);
      }, 100);
      console.log('Редактор синхронизирован с восстановленными строками');
      // --- СБРОС режима восстановления ---
      window.restoreModeEnabled = false;
    };
    // === Обработчик кнопки синхронизации редактора ===
    document.getElementById('syncEditorBtn').onclick = function() {
      if (window.restoreModeEnabled && typeof window.syncEditorWithRestored === 'function') {
        const confirmed = confirm(
          'Это заменит текущее содержимое редактора на восстановленные строки из файла.\n\n' +
          'Все несохранённые изменения в редакторе будут потеряны!\n\n' +
          'Продолжить?'
        );
        if (confirmed) {
          window.syncEditorWithRestored();
          alert('Редактор обновлён с восстановленными строками!');
          this.style.display = 'none';
        }
      } else {
        alert('Сначала выполните восстановление структуры!');
      }
    };
  </script>
</body>
</html>
